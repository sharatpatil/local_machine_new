
app.get("/search_new", async (req, res) => {
  try {
    let { query, last_fetched_id, limit = 10 } = req.query;
    limit = parseInt(limit);
    

    if (!query) {
      return res.status(400).json({ error: "Query parameter is required" });
    }

    let sql = `
      SELECT data FROM bpsi_intv_6rvginkmsnhgprpfmkalqoe1
      WHERE document_vector @@ to_tsquery('simple',$1)
      ${last_fetched_id ? "AND identity > $2" : ""}
      ORDER BY identity ASC
      LIMIT $3;
    `;

    const values = last_fetched_id ? [query, last_fetched_id, limit] : [query, limit];

    const result = await pool.query(sql, values);

    res.json(result.rows);
  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

Error: error: could not determine data type of parameter $2
    at C:\Users\2024698\bpsi-app-projects\react\node projects\node_modules\pg-pool\index.js:45:11
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async C:\Users\2024698\bpsi-app-projects\react\node projects\app.js:1063:20 {
  length: 111,

in query add like this for multiple search       WHERE document_vector @@ to_tsquery('simple', 'leid:* & 98556:*')








const express = require("express");
const { Pool } = require("pg");

const app = express();
const port = 3000;

const pool = new Pool({
  user: "your_user",
  host: "your_host",
  database: "your_db",
  password: "your_password",
  port: 5432,
});

app.get("/search", async (req, res) => {
  try {
    let { query, last_fetched_id, limit = 10 } = req.query;
    limit = parseInt(limit);

    if (!query) {
      return res.status(400).json({ error: "Query parameter is required" });
    }

    let sql = `
      SELECT * FROM your_table
      WHERE json_text_tsv @@ to_tsquery($1)
      ${last_fetched_id ? "AND identifier > $2" : ""}
      ORDER BY identifier ASC
      LIMIT $3;
    `;

    const values = last_fetched_id ? [query, last_fetched_id, limit] : [query, limit];

    const result = await pool.query(sql, values);

    res.json(result.rows);
  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

app.listen(port, () => {
  console.log(`Server running on http://localhost:${port}`);
});




curl "http://localhost:3000/search?query=developer&last_fetched_id=5&limit=10"

curl "http://localhost:3000/search?query=developer&limit=10"


SQL Error [54000]: ERROR: index row requires 8240 bytes, maximum size is 8191
  Where: parallel worker



const compression = require('compression');
const { Pool } = require('pg');
const NodeCache = require('node-cache');

const cache = new NodeCache({ stdTTL: 300, checkperiod: 120 }); // Cache with 5-minute TTL
const pool = new Pool({
  user: 'your_user',
  host: 'your_host',
  database: 'your_db',
  password: 'your_password',
  port: 5432,
  max: 10, // 👈 Connection pool size
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

const app = require('express')();
app.use(compression()); // Enable compression for large JSON responses

app.get('/multi_word_search_plainto', async (req, res) => {
  const { term = '', lastTimestamp, limit = 100, schema } = req.query;
  if (!term) return res.status(400).json({ error: 'Search term cannot be empty.' });

  const startTime = performance.now();
  const cacheKey = `multi_search:${term}:last:${lastTimestamp}:limit:${limit}:schema:${schema}`;

  try {
    // 1️⃣ **Check cache first (Async to avoid blocking)**
    const cachedData = await Promise.resolve(cache.get(cacheKey));
    if (cachedData) {
      console.log('✅ Serving from cache');
      return res.json({
        source: 'cache',
        responseTime: `${((performance.now() - startTime) / 1000).toFixed(3)} seconds`,
        highlight: term,
        count: cachedData.length,
        data: cachedData,
      });
    }

    // 2️⃣ **Prepare search query safely**
    const searchQuery = term.split(/\s+/).map((word) => `${word}:*`).join(' & ');

    const query = `
      SELECT data
      FROM ${schema}
      WHERE document_vector @@ to_tsquery('simple', $1)
      ORDER BY event_timestamp
      LIMIT $2;
    `;

    // 3️⃣ **Execute query with connection pooling**
    const { rows } = await pool.query(query, [searchQuery, parseInt(limit)]);

    // 4️⃣ **Store results in cache before sending response**
    cache.set(cacheKey, rows);

    const responseTime = ((performance.now() - startTime) / 1000).toFixed(3);
    res.json({ source: 'database', responseTime: `${responseTime} seconds`, highlight: term, count: rows.length, data: rows });

  } catch (error) {
    console.error('❌ Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});









00000000

app.get('/multi_word_search_plainto', async (req, res) => {
  const { term = '', lastTimestamp, limit = 100, schema } = req.query;

  const startTime = performance.now();
  const cacheKey = `multi_search:${term}:last:${lastTimestamp}:limit:${limit}:schema:${schema}`;

  try {
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      console.log('Serving from cache');
      const responseTime = ((performance.now() - startTime) / 1000).toFixed(3);
      return res.json({ source: 'cache', responseTime: `(${responseTime} seconds)`, highlight: term, count: cachedData.length, data: cachedData });
    }

    if (!term) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

    // Prepare search query
    const searchQuery = term.split(' ').map(ter => `${ter}:*`).join(' & ');

    const query = `
      SELECT data
      FROM ${schema}
      WHERE document_vector @@ to_tsquery('simple', $1)
      ORDER BY event_timestamp
      LIMIT $2;
    `;

    const values = [searchQuery, parseInt(limit)];

    // Fetch results from DB
    const { rows } = await pool.query(query, values);

    // Store result in cache
    cache.set(cacheKey, rows);
    const responseTime = ((performance.now() - startTime) / 1000).toFixed(3);

    res.json({ source: 'database', responseTime: `(${responseTime} seconds)`, highlight: term, count: rows.length, data: rows });
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});


/////////////



const compression = require('compression');
app.use(compression()); // Enable compression

app.get('/multi_word_search_plainto', async (req, res) => {
  const { term = '', lastTimestamp, limit = 100, schema } = req.query;

  const startTime = performance.now();
  const cacheKey = `multi_search:${term}:last:${lastTimestamp}:limit:${limit}:schema:${schema}`;

  try {
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      console.log('Serving from cache');
      const responseTime = ((performance.now() - startTime) / 1000).toFixed(3);
      return res.json({ source: 'cache', responseTime: `(${responseTime} seconds)`, highlight: term, count: cachedData.length, data: cachedData });
    }

    if (!term) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

    // Prepare search query
    const searchQuery = term.split(' ').map(ter => `${ter}:*`).join(' & ');

    const query = `
      SELECT data
      FROM ${schema}
      WHERE document_vector @@ to_tsquery('simple', $1)
      ORDER BY event_timestamp
      LIMIT $2;
    `;

    const values = [searchQuery, parseInt(limit)];

    // Fetch results from DB
    const { rows } = await pool.query(query, values);

    // Store result in cache
    cache.set(cacheKey, rows);
    const responseTime = ((performance.now() - startTime) / 1000).toFixed(3);

    res.json({ source: 'database', responseTime: `(${responseTime} seconds)`, highlight: term, count: rows.length, data: rows });
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});



..............





 SELECT  data
      FROM bpsi_intv_6rvginkmsnhgprpfmkalqoe1
      WHERE document_vector @@ to_tsquery('simple', 'leid:* & isic:* & 8778:*')
      ORDER BY event_timestamp
      LIMIT 5000;


app.get('/multi_word_search_plainto', async (req, res) => {
  const { term = '', lastTimestamp, limit = 100, schema } = req.query;

  const startTime = performance.now();
  const cacheKey = `multi_search:${term}:last:${lastTimestamp}:limit:${limit}:schema:${schema}`;

  try {
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      console.log('Serving from cache');
      const responseTime = ((performance.now() - startTime) / 1000).toFixed(3);
      return res.json({ source: 'cache', responseTime: `(${responseTime} seconds)`, highlight: term, count: cachedData.length, data: cachedData });
    }

    if (!term) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

    const searchQuery = term.split(' ').map(ter => `${ter}:*`).join(' & '); // Split terms by space and add wildcard


    const query = `
      SELECT data
      FROM ${schema}
      WHERE document_vector @@ to_tsquery('simple', '${searchQuery}')
      ORDER BY event_timestamp
      LIMIT $1;
    `;


    console.log(query)
    const values = [parseInt(limit)];
    const { rows } = await pool.query(query, values);

    console.log(values)

    cache.set(cacheKey, rows);
    const responseTime = ((performance.now() - startTime) / 1000).toFixed(3);

    res.json({ source: 'database', responseTime: `(${responseTime} seconds)`, highlight: term, count: rows.length, data: rows });
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});



i have modify the api like above its working but query is taking 1 sec to fetch records but api takes 2secs to fetch




app.get('/multi_word_search1', async (req, res) => {
  const { term = '', lastTimestamp, limit = 100, schema } = req.query;

  const startTime = performance.now();
  const cacheKey = `multi_search:${term}:last:${lastTimestamp}:limit:${limit}:schema:${schema}`;

  try {
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      console.log('Serving from cache');
      const responseTime = ((performance.now() - startTime) / 1000).toFixed(3);
      return res.json({ source: 'cache', responseTime: `(${responseTime} seconds)`, highlight: term, count: cachedData.length, data: cachedData });
    }

    if (!term) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

    const query = `
      SELECT event_timestamp, data
      FROM ${schema}
      WHERE document_vector @@ phraseto_tsquery('simple', $1)
      AND event_timestamp > $2
      ORDER BY event_timestamp
      LIMIT $3;
    `;

    const values = [term, lastTimestamp || '1970-01-01 00:00:00', parseInt(limit)];
    const { rows } = await pool.query(query, values);

    cache.set(cacheKey, rows);
    const responseTime = ((performance.now() - startTime) / 1000).toFixed(3);

    res.json({ source: 'database', responseTime: `(${responseTime} seconds)`, highlight: term, count: rows.length, data: rows });
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});






...........







app.get('/multi_word_search1', async (req, res) => {
  const { term = '', lastTimestamp, limit = 100, schema } = req.query;

  const startTime = performance.now();
  const cacheKey = `multi_search:${term}:last:${lastTimestamp}:limit:${limit}:schema:${schema}`;

  try {
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      console.log('Serving from cache');
      const responseTime = ((performance.now() - startTime) / 1000).toFixed(3);
      return res.json({ source: 'cache', responseTime: `(${responseTime} seconds)`, highlight: term, count: cachedData.length, data: cachedData });
    }

    const words = term.split(/\s+/).filter(Boolean);
    if (words.length === 0) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

    const searchQuery = words
      .map((_, index) => `document_vector @@ plainto_tsquery('simple', $${index + 1})`)
      .join(' AND ');

    const query = `
      SELECT event_timestamp, data FROM ${schema}
      WHERE ${searchQuery}
      AND event_timestamp > $${words.length + 1}
      ORDER BY event_timestamp
      LIMIT $${words.length + 2};
    `;

    const values = [...words, lastTimestamp || '1970-01-01 00:00:00', parseInt(limit)];
    const { rows } = await pool.query(query, values);

    cache.set(cacheKey, rows);
    const responseTime = ((performance.now() - startTime) / 1000).toFixed(3);

    res.json({ source: 'database', responseTime: `(${responseTime} seconds)`, highlight: term, count: rows.length, data: rows });
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});





mmmmmmmmm

  SELECT data
      FROM bpsi_intv_6rvginkmsnhgprpfmkalqoe1
      WHERE document_vector @@ to_tsquery('simple', 'leid:* & 98556:*' )
      order by event_timestamp
      limit 5000;

app.get('/multi_word_search1', async (req, res) => {
  const { term = '', page = 1, limit = 100, schema } = req.query;
  const offset = (page - 1) * limit;

   // Start measuring time
   const startTime = performance.now();

  // Create a unique cache key based on query parameters
  const cacheKey = `multi_search:${term}:page:${page}:limit:${limit}:schema:${schema}`;

  try {
    // Check if the result is already in the cache
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      console.log('Serving from cache');
      const endTime = performance.now();
      const responseTime = ((endTime - startTime) / 1000).toFixed(3); // Convert ms to seconds
      return res.json({ source: 'cache',  responseTime: `(${responseTime} seconds)`, highlight: term, count: cachedData.length, data: cachedData });
    }

    // Split the term into words
    const words = term.split(/\s+/).filter(Boolean); // Split by spaces and remove empty strings

    if (words.length === 0) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

    // Construct search query dynamically with :*
    const searchQuery = words
      .map((_, index) => `document_vector @@ to_tsquery('simple', $${index + 1} || ':*')`)
      .join(' AND ');

    // const query = `
    //   SELECT data
    //   FROM ${schema}
    //   WHERE ${searchQuery}
    //   ORDER BY 
    //   LIMIT $${words.length + 1} OFFSET $${words.length + 2};
    // `;
const query =`select event_timestamp,data from(   
      SELECT * FROM ${schema}
    WHERE ${searchQuery}) temps
    order by event_timestamp
    limit $${words.length + 1} OFFSET $${words.length + 2};`

    console.log(query)
    
    // Prepare parameter values
    const values = [...words, parseInt(limit), parseInt(offset)];

    console.log(values)

    console.log('Fetching from database');
    const { rows } = await pool.query(query, values);

    // Store the result in cache
    cache.set(cacheKey, rows);
    const endTime = performance.now();
    const responseTime = ((endTime - startTime) / 1000).toFixed(3); // Convert ms to seconds

    res.json({ source: 'database', responseTime: `(${responseTime} seconds)`, highlight: term, count: rows.length, data: rows });
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});





app.get('/search', async (req, res) => {
    const { limit = 50, offset = 0, table, terms } = req.query;

    if (!table || !terms) {  // Check if table and terms are provided
        return res.status(400).json({ error: 'Table name and search terms are required.' });
    }

    // Sanitize table name (important to prevent SQL injection!)
    const safeTable = table.replace(/[^a-zA-Z0-9_]/g, ''); // Remove any characters that are not alphanumeric or underscore

    // Dynamically build the search query
    const searchTerms = terms.split(' ').map(term => `${term}:*`).join(' & '); // Split terms by space and add wildcard
    const query = `
        SELECT data
        FROM ${safeTable}  -- Use the sanitized table name
        WHERE document_vector @@ to_tsquery('simple', '${searchTerms}')
        LIMIT $1 OFFSET $2;
    `;

    try {
        const result = await client.query(query, [limit, offset]);
        res.json(result.rows);
    } catch (err) {
        console.error('Error executing query:', err);
        res.status(500).json({ error: 'An error occurred' });
    }
});





SELECT data
      FROM bpsi_intv_6rvginkmsnhgprpfmkalqoe1
      WHERE document_vector @@ to_tsquery('simple', 'leid:* & 343434:*' )
--      order by event_timestamp 
      limit 50 offset 0; 
     



app.get('/multi_word_search1', async (req, res) => {
  const { term = '', page = 1, limit = 100, schema } = req.query;
  const offset = (page - 1) * limit;

  // Create a unique cache key based on query parameters
  const cacheKey = `multi_search:${term}:page:${page}:limit:${limit}:schema:${schema}`;

  try {
    // Check if the result is already in the cache
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      console.log('Serving from cache');
      return res.json({ source: 'cache', highlight: term, count: cachedData.length, data: cachedData });
    }

    // Split the term into words
    const words = term.split(/\s+/).filter(Boolean); // Split by spaces and remove empty strings

    if (words.length === 0) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

    // Construct search query dynamically with :*
    const searchQuery = words
      .map((_, index) => `document_vector @@ to_tsquery('simple', $${index + 1} || ':*')`)
      .join(' AND ');

    const query = `
      SELECT data
      FROM ${schema}
      WHERE ${searchQuery}
      LIMIT $${words.length + 1} OFFSET $${words.length + 2};
    `;

    console.log(query)
    
    // Prepare parameter values
    const values = [...words, parseInt(limit), parseInt(offset)];

    console.log(values)

    console.log('Fetching from database');
    const { rows } = await pool.query(query, values);

    // Store the result in cache
    cache.set(cacheKey, rows);

    res.json({ source: 'database', highlight: term, count: rows.length, data: rows });
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});



//////////////////////////////////


const getHighlightedData = (obj, depth = 0, maxDepth = 3) => {
  if (depth > maxDepth) return []; // Stop recursion at maxDepth

  const result = [];
  const searchWords = searchTerm?.toLowerCase().trim().split(/\s+/) || [];

  if (searchWords.length === 0) return result;

  // Create reversed words
  const reversedSearchWords = searchWords.map((word) =>
    word.split("").reverse().join("")
  );

  const allSearchWords = [...searchWords, ...reversedSearchWords];

  Object.entries(obj).forEach(([key, value]) => {
    if (typeof value === "object" && value !== null) {
      result.push(...getHighlightedData(value, depth + 1, maxDepth)); // Pass depth
    } else {
      const keyString = key.toLowerCase();
      const valueString = value?.toString().toLowerCase() || "";

      const keyMatches = allSearchWords.some((word) => keyString.includes(word));
      const valueMatches = allSearchWords.some((word) => valueString.includes(word));

      if (keyMatches || valueMatches) {
        result.push({ key, value });
      }
    }
  });

  return result;
};



const highlightedData = useMemo(() => getHighlightedData(item), [item, searchTerm]);


import { debounce } from 'lodash';

const [searchTerm, setSearchTerm] = useState('');

const debouncedSetSearchTerm = useCallback(debounce((value) => {
  setSearchTerm(value);
}, 300), []);

const handleSearchChange = (e) => {
  debouncedSetSearchTerm(e.target.value);
};


0000000



  const highlightText = (text) => {
    if (!searchTerm || typeof text !== "string") return text;
  
    // Escape special characters in the searchTerm and create regex for multiple words
    const escapedSearchTerm = escapeRegExp(searchTerm.trim());
    const words = escapedSearchTerm.split(/\s+/).map((word) => escapeRegExp(word)); // Split into words
  
    const allWords = words.flatMap((word) => [word, [...word].reverse().join("")]);

    // Generate regex for both word boundaries (\bword and word\b)
    const regexPattern = allWords
      .map((word) => `(\\b${word})|(${word}\\b)`) // Create patterns for both start and end
      .join("|");
  
    // Create a single regex for all words
    const regex = new RegExp(regexPattern, "gi");
    
    // console.log(regex)
    // Split text into parts using the regex
    const parts = text.split(regex);
  
    return parts.map((part, index) =>
      regex.test(part) ? (
        <span
          key={index}
          style={{
            backgroundColor: "#ffe58a",
            fontWeight: "bold",
            borderRadius: "2px",
          }}
        >
          {part}
        </span>
      ) : (
          part
        )
    );
  };



  const getHighlightedData = (obj) => {
    const result = [];
    const searchWords = searchTerm
      ?.toLowerCase()
      .trim()
      .split(/\s+/); // Split the search term into individual words
  
    if (!searchWords || searchWords.length === 0) return result;
  
    // Generate reversed words for each search term
    const reversedSearchWords = searchWords.map((word) =>
      word.split("").reverse().join("")
    );
  
    // Combine original and reversed search terms
    const allSearchWords = [...searchWords, ...reversedSearchWords];
  
    Object.entries(obj).forEach(([key, value]) => {
      const isNestedObject = typeof value === "object" && value !== null;
  
      // Ensure the key and value are strings for comparison
      const keyString = key?.toLowerCase() || ""; // Fallback to empty string if undefined
      const valueString = value?.toString().toLowerCase() || ""; // Fallback to empty string if undefined
  
      // Check if any search word matches the key or value
      const keyMatches = allSearchWords.some((word) => keyString.includes(word));
      const valueMatches = allSearchWords.some((word) => valueString.includes(word));
  
      if (isNestedObject) {
        // Recursively process nested objects
        result.push(...getHighlightedData(value));
      } else if (keyMatches || valueMatches) {
        // Add matches to the result
        result.push({ key, value });
      }
    });
  
    return result;
  };

  const highlightedData = getHighlightedData(item);

  return (
<Card code />
)


const { Pool } = require('pg');
const NodeCache = require('node-cache');

const pool = new Pool({
  user: 'your_user',
  host: 'your_host',
  database: 'your_db',
  password: 'your_password',
  port: 5432,
  max: 20, // Increased pool size
  idleTimeoutMillis: 30000, // Close idle connections after 30s
  connectionTimeoutMillis: 2000, // Timeout if no connection in 2s
});

const cache = new NodeCache({ stdTTL: 300 }); // Cache for 5 minutes

app.get('/multi_word_search', async (req, res) => {
  const { term = '', page = 1, limit = 100, schema } = req.query;
  const offset = (page - 1) * limit;

  // Cache key
  const cacheKey = `multi_search:${term}:page:${page}:limit:${limit}:schema:${schema}`;

  try {
    // Check cache first
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      console.log('Serving from cache');
      return res.json({ source: 'cache', count: cachedData.length, data: cachedData });
    }

    // Split search term into words
    const words = term.split(/\s+/).filter(Boolean);
    if (words.length === 0) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

    // Ensure index is used (Run `CREATE INDEX idx_document_vector ON your_table USING GIN (document_vector);` in DB)
    const searchQuery = words.map((_, i) => `document_vector @@ to_tsquery('simple', $${i + 1} || ':*')`).join(' AND ');

    // Optimized query
    const query = `
      SELECT data
      FROM ${schema}
      WHERE ${searchQuery}
      ORDER BY ts_rank(document_vector, to_tsquery('simple', $1)) DESC
      LIMIT $${words.length + 1} OFFSET $${words.length + 2};
    `;

    const values = [...words, parseInt(limit), parseInt(offset)];

    console.log('Fetching from database...');
    const { rows } = await pool.query(query, values);

    // Store in cache
    cache.set(cacheKey, rows);

    res.json({ source: 'database', count: rows.length, data: rows });
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});





mmmmmmmmm


app.get('/multi_word_search_time', async (req, res) => {
  const { term = '', page = 1, limit = 100, schema } = req.query;
  const offset = (page - 1) * limit;

  // Start measuring time
  const startTime = performance.now();

  // Create a unique cache key based on query parameters
  const cacheKey = `multi_search:${term}:page:${page}:limit:${limit}:schema:${schema}`;

  try {
    // Check if the result is already in the cache
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      const endTime = performance.now();
      const responseTime = ((endTime - startTime) / 1000).toFixed(3); // Convert ms to seconds

      console.log('Serving from cache');
      return res.json({
        source: 'cache',
        responseTime: `(${responseTime} seconds)`,
        highlight: term,
        count: cachedData.length,
        data: cachedData
      
      });
    }

    // Split the term into words
    const words = term.split(/\s+/).filter(Boolean); // Split by spaces and remove empty strings

    if (words.length === 0) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

    // Construct search query dynamically with :*
    const searchQuery = words
      .map((_, index) => `document_vector @@ to_tsquery('simple', $${index + 1} || ':*')`)
      .join(' AND ');

    const query = `
      SELECT data
      FROM ${schema}
      WHERE ${searchQuery}
      LIMIT $${words.length + 1} OFFSET $${words.length + 2};
    `;

    console.log(query);
    // Prepare parameter values
    const values = [...words, parseInt(limit), parseInt(offset)];

    console.log('Fetching from database');
    const { rows } = await pool.query(query, values);

    // Store the result in cache
    cache.set(cacheKey, rows);

    const endTime = performance.now();
    const responseTime = ((endTime - startTime) / 1000).toFixed(3); // Convert ms to seconds

    res.json({
      source: 'database',
      responseTime: `(${responseTime} seconds)`,
      highlight: term,
      count: rows.length,
      data: rows
    });
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});



/////////////////////////


const { performance } = require('perf_hooks');

app.get('/multi_word_search1', async (req, res) => {
  const { term = '', page = 1, limit = 100, schema } = req.query;
  const offset = (page - 1) * limit;

  // Start measuring time
  const startTime = performance.now();

  // Create a unique cache key based on query parameters
  const cacheKey = `multi_search:${term}:page:${page}:limit:${limit}:schema:${schema}`;

  try {
    // Check if the result is already in the cache
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      const endTime = performance.now();
      const responseTime = ((endTime - startTime) / 1000).toFixed(3); // Convert ms to seconds

      console.log('Serving from cache');
      return res.json({
        source: 'cache',
        highlight: term,
        count: cachedData.length,
        data: cachedData,
        responseTime: `${responseTime} seconds`
      });
    }

    // Split the term into words
    const words = term.split(/\s+/).filter(Boolean); // Split by spaces and remove empty strings

    if (words.length === 0) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

    // Construct search query dynamically with :*
    const searchQuery = words
      .map((_, index) => `document_vector @@ to_tsquery('simple', $${index + 1} || ':*')`)
      .join(' AND ');

    const query = `
      SELECT data
      FROM ${schema}
      WHERE ${searchQuery}
      LIMIT $${words.length + 1} OFFSET $${words.length + 2};
    `;

    console.log(query);
    // Prepare parameter values
    const values = [...words, parseInt(limit), parseInt(offset)];

    console.log('Fetching from database');
    const { rows } = await pool.query(query, values);

    // Store the result in cache
    cache.set(cacheKey, rows);

    const endTime = performance.now();
    const responseTime = ((endTime - startTime) / 1000).toFixed(3); // Convert ms to seconds

    res.json({
      source: 'database',
      highlight: term,
      count: rows.length,
      data: rows,
      responseTime: `${responseTime} seconds`
    });
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});


llllllllll



app.get('/multi_word_search1', async (req, res) => {
  const { term = '', page = 1, limit = 100, schema } = req.query;
  const offset = (page - 1) * limit;

  // Create a unique cache key based on query parameters
  const cacheKey = `multi_search:${term}:page:${page}:limit:${limit}:schema:${schema}`;

  try {
    // Check if the result is already in the cache
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      console.log('Serving from cache');
      return res.json({ source: 'cache', highlight: term, count: cachedData.length, data: cachedData });
    }

    // Split the term into words
    const words = term.split(/\s+/).filter(Boolean); // Split by spaces and remove empty strings

    if (words.length === 0) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

    // Construct search query dynamically with :*
    const searchQuery = words
      .map((_, index) => `document_vector @@ to_tsquery('simple', $${index + 1} || ':*')`)
      .join(' AND ');

    const query = `
      SELECT data
      FROM ${schema}
      WHERE ${searchQuery}
      LIMIT $${words.length + 1} OFFSET $${words.length + 2};
    `;

    console.log(query)
    // Prepare parameter values
    const values = [...words, parseInt(limit), parseInt(offset)];

    console.log('Fetching from database');
    const { rows } = await pool.query(query, values);

    // Store the result in cache
    cache.set(cacheKey, rows);

    res.json({ source: 'database', highlight: term, count: rows.length, data: rows });
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});


app.get('/multi_word_count', async (req, res) => {
  const { term = '', schema } = req.query;

  try {
    // Validate the schema and term
    if (!schema) {
      return res.status(400).json({ error: 'Schema is required.' });
    }

    // Split the term into words and filter out empty strings
    const words = term.split(/\s+/).filter(Boolean);

    if (words.length === 0) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

    // Generate a unique cache key based on the search term and schema
    const cacheKey = `multi_word_count:${term}:schema:${schema}`;

    // Check if the result is already cached
    const cachedCount = cache.get(cacheKey);
    if (cachedCount) {
      console.log('Serving count from cache');
      return res.json({ source: 'cache', ...cachedCount });
    }

    // Construct search condition dynamically with :*
    const searchCondition = words
      .map((_, index) => `document_vector @@ to_tsquery('simple', $${index + 1} || ':*')`)
      .join(' AND ');

    // Prepare parameter values
    const values = words;

    console.log('Fetching total count from database');

    // First query: Get total count for the search condition
    const countQuery = `
      SELECT COUNT(identity) AS totalCount
      FROM ${schema}
      WHERE ${searchCondition};
    `;
    const countResult = await pool.query(countQuery, values);
    const totalCount = parseInt(countResult.rows[0]?.totalcount || 0, 10);

    // Second query: Get total count of all rows in the schema
    const countQuery1 = `
      SELECT COUNT(data) AS totalCount1
      FROM ${schema};
    `;
    const countResult1 = await pool.query(countQuery1);
    const totalCount1 = parseInt(countResult1.rows[0]?.totalcount1 || 0, 10);

    // Cache the result for future requests (e.g., 5 minutes = 300 seconds)
    const cachedResult = { totalCount, totalCount1 };
    cache.set(cacheKey, cachedResult, 300);

    res.json(cachedResult);
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});
////////


WITH combined_data AS (
    SELECT data FROM bpsi_intv_6rvginkmsnhgprpfmkalqoe1 WHERE document_vector @@ to_tsquery('simple', 'leid:*')
    UNION ALL
    SELECT data FROM bpsi_intv_iglfamvkbhs8bixcmznfvukw WHERE document_vector @@ to_tsquery('simple', 'leid:*')
)
SELECT * FROM combined_data
LIMIT 50 OFFSET 3;



SELECT data FROM bpsi_intv_6rvginkmsnhgprpfmkalqoe1 
WHERE document_vector @@ to_tsquery('simple', 'leid:*')

UNION ALL

SELECT data FROM bpsi_intv_iglfamvkbhs8bixcmznfvukw
WHERE document_vector @@ to_tsquery('simple', 'leid:*')

ORDER BY data  -- Optional sorting
LIMIT 50 OFFSET 3;



.....





     SELECT data 
      FROM bpsi_intv_6rvginkmsnhgprpfmkalqoe1 and bpsi_intv_iglfamvkbhs8bixcmznfvukw
      WHERE document_vector @@ to_tsquery('simple', 'leid' || ':*')
      LIMIT 50 OFFSET 3;




const highlightText = (text) => {
  if (!searchTerm || typeof text !== "string") return text;

  // Escape special characters in the searchTerm and create regex for multiple words
  const escapedSearchTerm = escapeRegExp(searchTerm.trim());
  const words = escapedSearchTerm.split(/\s+/).map((word) => escapeRegExp(word)); // Split into words

  // Generate regex for both word boundaries (\bword and word\b)
  const regexPattern = words
    .map((word) => `(\b${word})|(${word}\b)`) // Create patterns for both start and end
    .join("|");

  // Create a single regex for all words
  const regex = new RegExp(regexPattern, "gi");

  // Split text into parts using the regex
  const parts = text.split(regex);

  return parts.map((part, index) =>
    regex.test(part) ? (
      <span
        key={index}
        style={{
          backgroundColor: "#ffe58a",
          fontWeight: "bold",
          borderRadius: "2px",
        }}
      >
        {part}
      </span>
    ) : (
        part
      )
  );
};


(\bkey)|(\baddr)|(key\b)|(addr\b)|(\bear)|(ear\b)



const regexPrefix = '(\b'+${allWords.join(")|(\b")}+')';
    const regexPostfix = '('+${allWords.join("\b)|(")}+'\b)';
    
    const regex = new RegExp(`(${allWords.join("|")})\\b`, "gi");




SQL Error [54000]: ERROR: string is too long for tsvector (1190206 bytes, max 1048575 bytes)

Error position:

UPDATE bpsi.bpsi_intv_d73052ddfb7dce80198c323e SET document_vector = to_tsvector('simple', data::text || ' ' || reverse(data::text));



const regex = new RegExp(`\\b(${allWords.join("|")})\\b`, "gi");
.


const regex = new RegExp(`(${allWords.join("|")})`, "gi");



app.get('/multi_word_count', async (req, res) => {
  const { term = '', schema } = req.query;

  try {
    // Validate the schema and term
    if (!schema) {
      return res.status(400).json({ error: 'Schema is required.' });
    }

    // Split the term into words and filter out empty strings
    const words = term.split(/\s+/).filter(Boolean);

    if (words.length === 0) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

    // Generate a unique cache key based on the search term and schema
    const cacheKey = `multi_word_count:${term}:schema:${schema}`;

    // Check if the result is already cached
    const cachedCount = cache.get(cacheKey);
    if (cachedCount) {
      console.log('Serving count from cache');
      return res.json({ source: 'cache', ...cachedCount });
    }

    // Construct search condition dynamically with :*
    const searchCondition = words
      .map((_, index) => `document_vector @@ to_tsquery('simple', $${index + 1} || ':*')`)
      .join(' AND ');

    // Prepare parameter values
    const values = words;

    console.log('Fetching total count from database');

    // First query: Get total count for the search condition
    const countQuery = `
      SELECT COUNT(identity) AS totalCount
      FROM ${schema}
      WHERE ${searchCondition};
    `;
    const countResult = await pool.query(countQuery, values);
    const totalCount = parseInt(countResult.rows[0]?.totalcount || 0, 10);

    // Second query: Get total count of all rows in the schema
    const countQuery1 = `
      SELECT COUNT(data) AS totalCount1
      FROM ${schema};
    `;
    const countResult1 = await pool.query(countQuery1);
    const totalCount1 = parseInt(countResult1.rows[0]?.totalcount1 || 0, 10);

    // Cache the result for future requests (e.g., 5 minutes = 300 seconds)
    const cachedResult = { totalCount, totalCount1 };
    cache.set(cacheKey, cachedResult, 300);

    res.json(cachedResult);
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});





,..........


app.get('/multi_word_count', async (req, res) => {
  const { term = '', schema } = req.query;

  try {
    // Split the term into words
    const words = term.split(/\s+/).filter(Boolean);

    if (words.length === 0) {
      return res.status(400).json({ error: 'Search term cannot be empty.' });
    }

        // Generate a unique cache key based on the search term and schema
        const cacheKey = `multi_word_count:${term}:schema:${schema}`;

        // Check if the result is already cached
        const cachedCount = cache.get(cacheKey);
        if (cachedCount !== undefined) {
          console.log('Serving count from cache');
          return res.json({ source: 'cache', totalCount: cachedCount });
        }

        

    // Construct search condition dynamically with :*
    const searchCondition = words
      .map((_, index) => `document_vector @@ to_tsquery('simple', $${index + 1} || ':*')`)
      .join(' AND ');

    // Prepare parameter values
    const values = words;

    console.log('Fetching total count from database');
    const countQuery = `
      SELECT COUNT(identity) AS totalCount
      FROM ${schema}
      WHERE ${searchCondition};
    `;
    const countResult = await pool.query(countQuery, values);

      
    const totalCount = parseInt(countResult.rows[0].totalcount, 10);

    const countQuery1 = `
    SELECT COUNT(data) AS totalCount1
    FROM ${schema}
  `;
  const countResult1 = await pool.query(countQuery1, values);

    
  const totalCount1 = parseInt(countResult1.rows[0].totalCount1, 10);

        // Cache the result for future requests
        cache.set(cacheKey, totalCount,totalCount1); // Cache for 5 minutes (300 seconds)

    res.json({ totalCount,totalCount1 });
  } catch (error) {
    console.error('Error:', error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});


///////////////


const highlightText = (text) => {
  if (!searchTerm || typeof text !== "string") return text;

  // Escape special characters in the search term and split into individual words
  const words = searchTerm
    .trim()
    .split(/\s+/) // Split the search term into words
    .map((word) => escapeRegExp(word)); // Escape special characters in each word

  // Create an array of both the original and reversed words
  const allWords = words.flatMap((word) => [word, [...word].reverse().join("")]);

  // Create a regex to match any of the words (straight or reversed)
  const regex = new RegExp(`(${allWords.join("|")})`, "gi");

  // Split text into parts using the regex
  const parts = text.split(regex);

  // Map through parts and highlight matches
  return parts.map((part, index) =>
    regex.test(part) ? (
      <span
        key={index}
        style={{
          backgroundColor: "#ffe58a",
          fontWeight: "bold",
          borderRadius: "2px",
        }}
      >
        {part}
      </span>
    ) : (
      part
    )
  );
};


11111111111111111
  const highlightText = (text) => {
    if (!searchTerm || typeof text !== "string") return text;
  
    // Escape special characters in the searchTerm
    const escapedSearchTerm = escapeRegExp(searchTerm.trim());
  
    // Reverse the search term
    const reversedSearchTerm = [...escapedSearchTerm].reverse().join("");
  
    // Create regex to match both the search term and its reversed version
    const regex = new RegExp(`(${escapedSearchTerm}|${reversedSearchTerm})`, "gi");
  
    // Split text into parts using the regex
    const parts = text.split(regex);
  

    console.log(parts)
    // Map through parts and highlight matches
    return parts.map((part, index) =>
      regex.test(part) ? (
        <span
          key={index}
          style={{
            backgroundColor: "#ffe58a",
            fontWeight: "bold",
            borderRadius: "2px",
          }}
        >
          {part}
        </span>
      ) : (
        part
      )
    );
  };




.,.,.,.




const getHighlightedData = (obj) => {
  const result = [];
  const searchWords = searchTerm
    ?.toLowerCase()
    .trim()
    .split(/\s+/); // Split the search term into individual words

  if (!searchWords || searchWords.length === 0) return result;

  // Generate reversed words for each search term
  const reversedSearchWords = searchWords.map((word) =>
    word.split("").reverse().join("")
  );

  // Combine original and reversed search terms
  const allSearchWords = [...searchWords, ...reversedSearchWords];

  Object.entries(obj).forEach(([key, value]) => {
    const isNestedObject = typeof value === "object" && value !== null;

    // Ensure the key and value are strings for comparison
    const keyString = key?.toLowerCase() || ""; // Fallback to empty string if undefined
    const valueString = value?.toString().toLowerCase() || ""; // Fallback to empty string if undefined

    // Check if any search word matches the key or value
    const keyMatches = allSearchWords.some((word) => keyString.includes(word));
    const valueMatches = allSearchWords.some((word) => valueString.includes(word));

    if (isNestedObject) {
      // Recursively process nested objects
      result.push(...getHighlightedData(value));
    } else if (keyMatches || valueMatches) {
      // Add matches to the result
      result.push({ key, value });
    }
  });

  return result;
};

/////////////////
  const getHighlightedData = (obj) => {
    const result = [];
    const searchWords = searchTerm
      ?.toLowerCase()
      .trim()
      .split(/\s+/); // Split the search term into individual words

    if (!searchWords || searchWords.length === 0) return result;

    Object.entries(obj).forEach(([key, value]) => {
      const isNestedObject = typeof value === "object" && value !== null;

      // Ensure the key and value are strings for comparison
      const keyString = key?.toLowerCase() || ""; // Fallback to empty string if undefined
      const valueString = value?.toString().toLowerCase() || ""; // Fallback to empty string if undefined

      // Check if any search word matches the key or value
      const keyMatches = searchWords.some((word) => keyString.includes(word));
      const valueMatches = searchWords.some((word) => valueString.includes(word));

      if (isNestedObject) {
        // Recursively process nested objects
        result.push(...getHighlightedData(value));
      } else if (keyMatches || valueMatches) {
        // Add matches to the result
        result.push({ key, value });
      }
    });

    return result;
  };

..


const highlightText = (text) => {
  if (!searchTerm || typeof text !== "string") return text;

  // Escape special characters in the search term
  const escapeRegExp = (str) =>
    str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

  // Split the search term into individual words
  const searchWords = searchTerm.trim().split(/\s+/);

  // Create regex for both original and reversed search terms
  const escapedSearchTerm = searchWords.map(escapeRegExp).join("\\s+");
  const escapedReversedSearchTerm = searchWords
    .reverse()
    .map(escapeRegExp)
    .join("\\s+");
  const regex = new RegExp(
    `(${escapedSearchTerm}|${escapedReversedSearchTerm})`,
    "gi"
  );

  // Split the text into parts using the regex
  const parts = text.split(regex);

  return parts.map((part, index) => {
    // Reverse the current part to check against the reversed search term
    const isHighlighted = regex.test(part);

    return isHighlighted ? (
      <span
        key={index}
        style={{
          backgroundColor: "#ffe58a",
          fontWeight: "bold",
          borderRadius: "2px",
        }}
      >
        {part}
      </span>
    ) : (
      part
    );
  });
};





const highlightText = (text) => {
  if (!searchTerm || typeof text !== "string") return text;

  // Escape special characters in the search term
  const escapeRegExp = (str) =>
    str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

  // Split the search term into individual words
  const searchWords = searchTerm.trim().split(/\s+/);

  // Reverse the search term string
  const reversedSearchTerm = searchWords.reverse().join(" ");

  // Create regex for both original and reversed search terms
  const escapedSearchTerm = escapeRegExp(searchTerm.trim());
  const escapedReversedSearchTerm = escapeRegExp(reversedSearchTerm.trim());
  const regex = new RegExp(
    `(${escapedSearchTerm}|${escapedReversedSearchTerm})`,
    "gi"
  );

  // Function to reverse a string
  const reverseString = (str) => str.split("").reverse().join("");

  // Split the text into parts using regex
  const parts = text.split(regex);

  return parts.map((part, index) => {
    const isHighlighted =
      regex.test(part) || regex.test(reverseString(part)); // Check both original and reversed

    return isHighlighted ? (
      <span
        key={index}
        style={{
          backgroundColor: "#ffe58a",
          fontWeight: "bold",
          borderRadius: "2px",
        }}
      >
        {part}
      </span>
    ) : (
      part
    );
  });
};




const highlightText = (text) => {
  if (!searchTerm || typeof text !== "string") return text;

  // Escape special characters in the search term
  const escapeRegExp = (str) =>
    str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // Escapes special characters

  // Split the search term into individual words
  const words = searchTerm.trim().split(/\s+/);

  // Generate an array of original and reversed words
  const wordsWithReverses = words.flatMap((word) => {
    const escapedWord = escapeRegExp(word);
    const reversedWord = escapeRegExp([...word].reverse().join(""));
    return [escapedWord, reversedWord];
  });

  // Create a regex to match any of the original or reversed words
  const regex = new RegExp(`(${wordsWithReverses.join("|")})`, "gi");

  // Split text into parts using the regex
  const parts = text.split(regex);

  // Highlight matching parts
  return parts.map((part, index) =>
    regex.test(part) ? (
      <span
        key={index}
        style={{
          backgroundColor: "#ffe58a",
          fontWeight: "bold",
          borderRadius: "2px",
        }}
      >
        {part}
      </span>
    ) : (
      part
    )
  );
};





const highlightText = (text) => {
  if (!searchTerm || typeof text !== "string") return text;

  // Escape special characters in the searchTerm
  const escapeRegExp = (str) =>
    str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // Escapes special characters

  const escapedSearchTerm = escapeRegExp(searchTerm.trim());
  const reversedSearchTerm = escapeRegExp([...searchTerm.trim()].reverse().join(""));

  // Create regex to match both the search term and its reversed version
  const regex = new RegExp(`(${escapedSearchTerm}|${reversedSearchTerm})`, "gi");

  // Split text into parts using the regex
  const parts = text.split(regex);

  // Highlight the matching parts
  return parts.map((part, index) =>
    regex.test(part) ? (
      <span
        key={index}
        style={{
          backgroundColor: "#ffe58a",
          fontWeight: "bold",
          borderRadius: "2px",
        }}
      >
        {part}
      </span>
    ) : (
      part
    )
  );
};


///////////////////////////////////



const highlightText = (text) => {
  if (!searchTerm || typeof text !== "string") return text;

  // Escape special characters in the searchTerm
  const escapedSearchTerm = escapeRegExp(searchTerm.trim());

  // Reverse the search term
  const reversedSearchTerm = [...escapedSearchTerm].reverse().join("");

  // Create regex to match both the search term and its reversed version
  const regex = new RegExp(`(${escapedSearchTerm}|${reversedSearchTerm})`, "gi");

  // Split text into parts using the regex
  const parts = text.split(regex);

  // Map through parts and highlight matches
  return parts.map((part, index) =>
    regex.test(part) ? (
      <span
        key={index}
        style={{
          backgroundColor: "#ffe58a",
          fontWeight: "bold",
          borderRadius: "2px",
        }}
      >
        {part}
      </span>
    ) : (
      part
    )
  );
};



////////////////////////


const highlightText = (text) => {
    if (!searchTerm || typeof text !== "string") return text;

    // Escape special characters in the searchTerm and create regex for multiple words
    const escapedSearchTerm = escapeRegExp(searchTerm.trim());
    const words = escapedSearchTerm.split(/\s+/).map((word) => escapeRegExp(word)); // Split into words
    const regex = new RegExp(`(${words.join("|")})`, "gi"); // Create regex for all words

    // Split text into parts using the regex
    const parts = text.split(regex);

    return parts.map((part, index) =>
      regex.test(part) ? (
        <span
          key={index}
          style={{
            backgroundColor: "#ffe58a",
            fontWeight: "bold",
            borderRadius: "2px",
          }}
        >
          {part}
        </span>
      ) : (
        part
      )
    );
  };




import { Card, CardContent, Box, IconButton } from "@mui/material";
import VisibilityIcon from "@mui/icons-material/Visibility";

function CardViewWithIcons() {
  return (
    <Card
      sx={{
        width: 300, // Set card width
        height: 200, // Set card height
        position: "relative", // Make the card a positioned container
        boxShadow: 3, // Optional shadow
        borderRadius: 2, // Optional rounded corners
        padding: 2, // Optional padding
      }}
    >
      <CardContent>
        {/* Card content goes here */}
        <p>This is some content inside the card.</p>
      </CardContent>

      {/* Icons aligned to the bottom-right corner */}
      <Box
        sx={{
          position: "absolute",
          bottom: 8, // Offset from bottom
          right: 8, // Offset from right
          display: "flex",
          flexDirection: "row",
          gap: 1, // Spacing between icons
        }}
      >
        <IconButton onClick={() => console.log("Clicked visibility")}>
          <VisibilityIcon sx={{ color: "grey" }} />
        </IconButton>
        <IconButton onClick={() => console.log("Clicked visibility")}>
          <VisibilityIcon sx={{ color: "grey" }} />
        </IconButton>
        <IconButton onClick={() => console.log("Clicked visibility")}>
          <VisibilityIcon sx={{ color: "grey" }} />
        </IconButton>
      </Box>
    </Card>
  );
}

export default CardViewWithIcons;


////////////////////////////////


<Box
  sx={{
    position: "absolute",
    bottom: 0,
    right: 0,
    display: "flex",
    flexDirection: "row",
    alignItems: "flex-end",
    gap: "8px", // Adds spacing between icons
    padding: "10px", // Optional padding
  }}
>
  <IconButton onClick={() => setModalOpen(true)}>
    <VisibilityIcon sx={{ color: "grey" }} />
  </IconButton>
  <IconButton onClick={() => setModalOpen(true)}>
    <VisibilityIcon sx={{ color: "grey" }} />
  </IconButton>
  <IconButton onClick={() => setModalOpen(true)}>
    <VisibilityIcon sx={{ color: "grey" }} />
  </IconButton>
</Box>


/////////////////////////////////////////

<Box style={{display:"flex", flexDirection:'row', alignItems:'flex-end'}}> 
          <IconButton onClick={() => setModalOpen(true)}>
            <VisibilityIcon sx={{ color: "grey" }} />
          </IconButton>
          <IconButton onClick={() => setModalOpen(true)}>
            <VisibilityIcon sx={{ color: "grey" }} />
          </IconButton>
          <IconButton onClick={() => setModalOpen(true)}>
            <VisibilityIcon sx={{ color: "grey" }} />
          </IconButton>
          </Box>



import SearchData from './SearchData';
import SearchQuery from './SearchQuery';
import { useState } from "react";
import "./Search.scss";

function Search() {
    const [data, setData] = useState([]);
    const [term, setTerm] = useState([]);
    const [schema, setSchema] = useState('');
    const [totalCount, setTotalCount] = useState(0);

    return (
        <div className="main">
            <div className="search-query-container">
                <SearchQuery 
                    setData={setData} 
                    setTerm={setTerm} 
                    setSchema={setSchema} 
                    setTotalCount={setTotalCount} 
                />
            </div>
            <div className="search-data-container">
                <SearchData 
                    data={data} 
                    term={term} 
                    totalCount={totalCount} 
                />
            </div>
        </div>
    );
}

export default Search;




.main {
  display: flex;
  flex-direction: column;
  height: 100vh; /* Full height */
  overflow: hidden; /* Prevent overall scroll */
}

.search-query-container {
  flex: 0 0 auto; /* Fixed height */
  max-height: 30%; /* Adjust as needed */
  overflow-y: auto; /* Enable vertical scrolling */
  padding: 10px;
  border-bottom: 1px solid #ddd;
  background-color: #f9f9f9;
}

.search-data-container {
  flex: 1 1 auto; /* Remaining space for data */
  overflow-y: auto; /* Enable vertical scrolling */
  padding: 10px;
}

/////////////////////////////////////////////////////////

import SearchData from './SearchData';
import SearchQuery from './SearchQuery';
import {useState} from "react";
import "./Search.scss";





function Search() {
    const [data, setData] = useState([]);
    const [term, setTerm] = useState([]);
    const [schema, setSchema] = useState('');
    const [totalCount, setTotalCount] = useState(0);
    
    
    return (
        <div class ="main">
        <SearchQuery setData={setData} setTerm={setTerm} setSchema={setSchema} setTotalCount={setTotalCount}/>
        <SearchData data={data} term={term} totalCount={totalCount}/>
        
     
        </div>

    );

}

export default Search;





const renderTree = (data, path = "") => {
  return Object.entries(data).map(([key, value]) => {
    const nodePath = path ? `${path}.${key}` : key;
    const isExpandable = typeof value === "object" && value !== null;
    const matchesSearchKey = searchTerm && key.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesSearchValue = searchTerm && JSON.stringify(value).toLowerCase().includes(searchTerm.toLowerCase());
    const highlightKey = highlightText(key);  // Function to highlight search term in the key
    const highlightValue = highlightText(String(value));  // Function to highlight search term in the value

    return (
      <Box key={nodePath} sx={{ ml: 2, mt: 1 }}>
        <Box
          sx={{
            display: "flex",
            alignItems: "center",
            cursor: isExpandable ? "pointer" : "default",
            backgroundColor: matchesSearchKey || matchesSearchValue ? "#e0f7fa" : "transparent",  // Highlight area
            padding: "5px",
            borderRadius: "5px",
            transition: "background-color 0.2s",
          }}
          onClick={() => isExpandable && toggleNode(nodePath)}
        >
          {isExpandable ? (
            expandedNodes[nodePath] ? (
              <ExpandMoreIcon sx={{ fontSize: 16, mr: 1 }} />
            ) : (
              <ChevronRightIcon sx={{ fontSize: 16, mr: 1 }} />
            )
          ) : (
            <Box sx={{ width: 16, mr: 1 }} />
          )}
          <Typography
            component="span"
            sx={{
              fontWeight: isExpandable ? "bold" : "normal",
              color: matchesSearchKey ? "#00796b" : matchesSearchValue ? "#00796b" : "#000",
            }}
          >
            {highlightKey}:  {/* Highlighted Key */}
          </Typography>
          {!isExpandable && (
            <Typography
              component="span"
              sx={{
                ml: 1,
                color: "gray",
                fontFamily: "monospace",
                wordBreak: "break-word",
              }}
            >
              {highlightValue}  {/* Highlighted Value */}
            </Typography>
          )}
        </Box>
        {isExpandable && (matchesSearchKey || matchesSearchValue) && (
          <Collapse in={expandedNodes[nodePath]}>
            <Box sx={{ ml: 2 }}>{renderTree(value, nodePath)}</Box>
          </Collapse>
        )}
      </Box>
    );
  });
};

//////////////////////////////////////////////////////////////////////////////////////



import React, { useState } from 'react';
import { Box, Typography } from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ChevronRightIcon from '@mui/icons-material/ChevronRight';
// Import Collapse from MUI X
import Collapse from '@mui/material/Collapse';


const [expandedNodes, setExpandedNodes] = useState({});

const toggleNode = (path) => {
  setExpandedNodes((prevExpandedNodes) => ({
    ...prevExpandedNodes,
    [path]: !prevExpandedNodes[path],
  }));
};



const renderTree = (data, path = "") => {
  return Object.entries(data).map(([key, value]) => {
    const nodePath = path ? `${path}.${key}` : key;
    const isExpandable = typeof value === "object" && value !== null;
    const matchesSearch = searchTerm && key.toLowerCase().includes(searchTerm.toLowerCase());
    const highlightKey = highlightText(key);  // Function to highlight search term in the key

    return (
      <Box key={nodePath} sx={{ ml: 2, mt: 1 }}>
        <Box
          sx={{
            display: "flex",
            alignItems: "center",
            cursor: isExpandable ? "pointer" : "default",
            backgroundColor: matchesSearch ? "#e0f7fa" : "transparent",  // Highlight area
            padding: "5px",
            borderRadius: "5px",
            transition: "background-color 0.2s",
          }}
          onClick={() => isExpandable && toggleNode(nodePath)}
        >
          {isExpandable ? (
            expandedNodes[nodePath] ? (
              <ExpandMoreIcon sx={{ fontSize: 16, mr: 1 }} />
            ) : (
              <ChevronRightIcon sx={{ fontSize: 16, mr: 1 }} />
            )
          ) : (
            <Box sx={{ width: 16, mr: 1 }} />
          )}
          <Typography
            component="span"
            sx={{
              fontWeight: isExpandable ? "bold" : "normal",
              color: matchesSearch ? "#00796b" : "#000",
            }}
          >
            {highlightKey}:  {/* Highlighted Key */}
          </Typography>
          {!isExpandable && (
            <Typography
              component="span"
              sx={{
                ml: 1,
                color: "gray",
                fontFamily: "monospace",
                wordBreak: "break-word",
              }}
            >
              {highlightText(String(value))}  {/* Highlighted Value */}
            </Typography>
          )}
        </Box>
        {isExpandable && (
          <Collapse in={expandedNodes[nodePath]}>
            <Box sx={{ ml: 2 }}>{renderTree(value, nodePath)}</Box>
          </Collapse>
        )}
      </Box>
    );
  });
};

/////////////////////////////////////////



const [expandedNodes, setExpandedNodes] = useState({});

const toggleNode = (nodePath) => {
  setExpandedNodes((prevState) => ({
    ...prevState,
    [nodePath]: !prevState[nodePath],
  }));
};



Line 93:19:   'isExpanded' is not defined  no-undef
  Line 111:16:  'Collapse' is not defined    react/jsx-no-undef
  Line 111:29:  'isExpanded' is not defined  no-undef


const renderTree = (data, path = "") => {
  return Object.entries(data).map(([key, value]) => {
    const nodePath = path ? `${path}.${key}` : key;
    const isExpandable = typeof value === "object" && value !== null;
    const matchesSearch = searchTerm && key.toLowerCase().includes(searchTerm.toLowerCase());

    return (
      <Box key={nodePath}>
        <Box
          sx={{
            display: "flex",
            alignItems: "center",
            cursor: isExpandable ? "pointer" : "default",
            backgroundColor: matchesSearch ? "#e0f7fa" : "transparent", // Highlight area
            padding: "5px",
            borderRadius: "5px",
            transition: "background-color 0.2s",
          }}
          onClick={() => isExpandable && toggleNode(nodePath)}
        >
          {isExpandable ? (
            isExpanded[nodePath] ? (
              <ExpandMoreIcon sx={{ fontSize: 16, mr: 1 }} />
            ) : (
              <ChevronRightIcon sx={{ fontSize: 16, mr: 1 }} />
            )
          ) : (
            <Box sx={{ width: 16, mr: 1 }} />
          )}
          <Typography
            component="span"
            sx={{
              fontWeight: isExpandable ? "bold" : "normal",
              color: matchesSearch ? "#00796b" : "#000",
            }}
          >
            {highlightText(key)}:
          </Typography>
        </Box>
        <Collapse in={isExpanded[nodePath] || matchesSearch}>
          <Box sx={{ ml: 2 }}>
            {!isExpandable && <Typography sx={{ color: "gray", fontFamily: "monospace" }}>{highlightText(String(value))}</Typography>}
            {isExpandable && renderTree(value, nodePath)}
          </Box>
        </Collapse>
      </Box>
    );
  });
};




const renderTree = (data, path = "") => {
  return Object.entries(data).map(([key, value]) => {
    const nodePath = path ? `${path}.${key}` : key;
    const isExpandable = typeof value === "object" && value !== null;
    const matchesSearch = searchTerm && key.toLowerCase().includes(searchTerm.toLowerCase());
    const highlightKey = highlightText(key);  // Function to highlight search term in the key

    return (
      <Box key={nodePath} sx={{ ml: 2, mt: 1 }}>
        <Box
          sx={{
            display: "flex",
            alignItems: "center",
            cursor: isExpandable ? "pointer" : "default",
            backgroundColor: matchesSearch ? "#e0f7fa" : "transparent",  // Highlight area
            padding: "5px",
            borderRadius: "5px",
            transition: "background-color 0.2s",
          }}
          onClick={() => isExpandable && toggleNode(nodePath)}
        >
          {isExpandable ? (
            expandedNodes[nodePath] ? (
              <ExpandMoreIcon sx={{ fontSize: 16, mr: 1 }} />
            ) : (
              <ChevronRightIcon sx={{ fontSize: 16, mr: 1 }} />
            )
          ) : (
            <Box sx={{ width: 16, mr: 1 }} />
          )}
          <Typography
            component="span"
            sx={{
              fontWeight: isExpandable ? "bold" : "normal",
              color: matchesSearch ? "#00796b" : "#000",
            }}
          >
            {highlightKey}:  {/* Highlighted Key */}
          </Typography>
          {!isExpandable && (
            <Typography
              component="span"
              sx={{
                ml: 1,
                color: "gray",
                fontFamily: "monospace",
                wordBreak: "break-word",
              }}
            >
              {highlightText(String(value))}  {/* Highlighted Value */}
            </Typography>
          )}
        </Box>
        {isExpandable && expandedNodes[nodePath] && (
          <Box sx={{ ml: 2 }}>{renderTree(value, nodePath)}</Box>
        )}
      </Box>
    );
  });
};


///////////////////////////////////////////////////////////////


const renderTree = (data, path = "") => {
  return Object.entries(data).map(([key, value]) => {
    const nodePath = path ? `${path}.${key}` : key;
    const isExpandable = typeof value === "object" && value !== null;
    const isExpanded = expandedNodes[nodePath] || false;
    const matchesSearch = searchTerm && key.toLowerCase().includes(searchTerm.toLowerCase());

    return (
      <Box key={nodePath} sx={{ ml: 2, mt: 1 }}>
        <Box
          sx={{
            display: "flex",
            alignItems: "center",
            cursor: isExpandable ? "pointer" : "default",
            backgroundColor: matchesSearch ? "#e0f7fa" : "transparent", // Highlight area
            padding: "5px",
            borderRadius: "5px",
            transition: "background-color 0.2s",
          }}
          onClick={() => isExpandable && toggleNode(nodePath)}
        >
          {isExpandable ? (
            isExpanded ? (
              <ExpandMoreIcon sx={{ fontSize: 16, mr: 1 }} />
            ) : (
              <ChevronRightIcon sx={{ fontSize: 16, mr: 1 }} />
            )
          ) : (
            <Box sx={{ width: 16, mr: 1 }} />
          )}
          <Typography
            component="span"
            sx={{
              fontWeight: isExpandable ? "bold" : "normal",
              color: matchesSearch ? "#00796b" : "#000",
            }}
          >
            {highlightText(key)}:
          </Typography>
          {!isExpandable && (
            <Typography
              component="span"
              sx={{
                ml: 1,
                color: "gray",
                fontFamily: "monospace",
                wordBreak: "break-word",
              }}
            >
              {highlightText(String(value))}
            </Typography>
          )}
        </Box>
        {isExpandable && isExpanded && (
          <Box sx={{ ml: 2 }}>{renderTree(value, nodePath)}</Box>
        )}
      </Box>
    );
  });
};




Line 45:33:  'escapeRegExp' is not defined  no-undef
  Line 46:66:  'escapeRegExp' is not defined  no-undef


function JsonModal({ modalOpen, setModalOpen, item, searchTerm }) {
  const [expandedNodes, setExpandedNodes] = useState({});

  // Expand all nodes when modal opens
  useEffect(() => {
    if (modalOpen) {
      const expandAllNodes = (data, path = "") => {
        const nodes = {};
        Object.entries(data).forEach(([key, value]) => {
          const nodePath = path ? `${path}.${key}` : key;
          nodes[nodePath] = true; // Mark as expanded
          if (typeof value === "object" && value !== null) {
            Object.assign(nodes, expandAllNodes(value, nodePath));
          }
        });
        return nodes;
      };
      setExpandedNodes(expandAllNodes(item));
    }
  }, [modalOpen, item]);

  // Handle node toggle
  const toggleNode = (path) => {
    setExpandedNodes((prev) => ({ ...prev, [path]: !prev[path] }));
  };

  // Highlight matching text
  const highlightText = (text) => {
    if (!searchTerm || typeof text !== "string") return text;

    const escapedSearchTerm = escapeRegExp(searchTerm.trim());
    const words = escapedSearchTerm.split(/\s+/).map((word) => escapeRegExp(word)); // Split into words
    const regex = new RegExp(`(${words.join("|")})`, "gi"); // Create regex for all words

    const parts = text.split(regex);
    return parts.map((part, index) =>
      regex.test(part) ? (
        <span
          key={index}
          style={{
            backgroundColor: "#ffe58a",
            fontWeight: "bold",
            borderRadius: "2px",
          }}
        >
          {part}
        </span>
      ) : (
        part
      )
    );
  };

  // Recursive Tree Rendering with Highlight and Expansion
  const renderTree = (data, path = "") => {
    return Object.entries(data).map(([key, value]) => {
      const nodePath = path ? `${path}.${key}` : key;
      const isExpandable = typeof value === "object" && value !== null;
      const isExpanded = expandedNodes[nodePath];
      const matchesSearch = searchTerm && key.toLowerCase().includes(searchTerm.toLowerCase());

      return (
        <Box key={nodePath} sx={{ ml: 2, mt: 1 }}>
          <Box
            sx={{
              display: "flex",
              alignItems: "center",
              cursor: isExpandable ? "pointer" : "default",
            }}
            onClick={() => isExpandable && toggleNode(nodePath)}
          >
            {isExpandable ? (
              isExpanded ? (
                <ExpandMoreIcon sx={{ fontSize: 16, mr: 1 }} />
              ) : (
                <ChevronRightIcon sx={{ fontSize: 16, mr: 1 }} />
              )
            ) : (
              <Box sx={{ width: 16, mr: 1 }} />
            )}
            <Typography
              component="span"
              sx={{
                fontWeight: isExpandable ? "bold" : "normal",
                color: isExpandable ? "#3f51b5" : "#000",
              }}
            >
              {highlightText(key)}:
            </Typography>
            {!isExpandable && (
              <Typography
                component="span"
                sx={{ ml: 1, color: "gray", fontFamily: "monospace" }}
              >
                {highlightText(String(value))}
              </Typography>
            )}
          </Box>
          {isExpandable && isExpanded && (
            <Box sx={{ ml: 2 }}>{renderTree(value, nodePath)}</Box>
          )}
        </Box>
      );
    });
  };

  const handleCopy = () => {
    navigator.clipboard.writeText(JSON.stringify(item, null, 2));
    alert("JSON copied to clipboard!");
  };

  const handleDownload = () => {
    const blob = new Blob([JSON.stringify(item, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "domain-json.json";
    link.click();
  };

  return (
    <Modal
      open={modalOpen}
      onClose={() => setModalOpen(false)}
      aria-labelledby="json-modal"
      aria-describedby="json-modal-description"
    >
      <Box
        sx={{
          position: "absolute",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          width: "600px",
          bgcolor: "background.paper",
          border: "1px solid #ddd",
          borderRadius: "10px",
          boxShadow: 24,
          p: 4,
          maxHeight: "80%",
          overflowY: "auto",
        }}
      >
        {/* Modal Header */}
        <Box
          sx={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            mb: 2,
          }}
        >
          <Typography
            id="json-modal"
            variant="h6"
            component="h2"
            sx={{ color: "#3f51b5" }}
          >
            Domain JSON Viewer
          </Typography>
          <Box>
            <Tooltip title="Copy JSON">
              <IconButton onClick={handleCopy}>
                <ContentCopyIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Download JSON">
              <IconButton onClick={handleDownload}>
                <FileDownloadIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Close">
              <IconButton onClick={() => setModalOpen(false)}>
                <CloseIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
          </Box>
        </Box>

        {/* Custom Tree Viewer */}
        <Box
          sx={{
            bgcolor: "#f5f5f5",
            padding: "10px",
            borderRadius: "5px",
            maxHeight: "400px",
            overflowY: "auto",
            border: "1px solid #ddd",
          }}
        >
          {renderTree(item)}
        </Box>
      </Box>
    </Modal>
  );
}

export default JsonModal;


/////////////////////////////////////////////////////////////////////
  const highlightText = (text) => {
    if (!searchTerm || typeof text !== "string") return text;

    // Escape special characters in the searchTerm and create regex for multiple words
    const escapedSearchTerm = escapeRegExp(searchTerm.trim());
    const words = escapedSearchTerm.split(/\s+/).map((word) => escapeRegExp(word)); // Split into words
    const regex = new RegExp(`(${words.join("|")})`, "gi"); // Create regex for all words

    // Split text into parts using the regex
    const parts = text.split(regex);

    return parts.map((part, index) =>
      regex.test(part) ? (
        <span
          key={index}
          style={{
            backgroundColor: "#ffe58a",
            fontWeight: "bold",
            borderRadius: "2px",
          }}
        >
          {part}
        </span>
      ) : (
        part
      )
    );
  };


<JsonModal modalOpen={modalOpen} setModalOpen={setModalOpen} item={sampleData} />



import React, { useState, useEffect } from "react";
import {
  Modal,
  Box,
  IconButton,
  Typography,
  Tooltip,
} from "@mui/material";
import CloseIcon from "@mui/icons-material/Close";
import FileDownloadIcon from "@mui/icons-material/FileDownload";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import ChevronRightIcon from "@mui/icons-material/ChevronRight";

function JsonModal({ modalOpen, setModalOpen, item }) {
  const [expandedNodes, setExpandedNodes] = useState({}); // Tracks expanded/collapsed state of nodes

  // Expand all nodes when modal opens
  useEffect(() => {
    if (modalOpen) {
      const expandAllNodes = (data, path = "") => {
        const nodes = {};
        Object.entries(data).forEach(([key, value]) => {
          const nodePath = path ? `${path}.${key}` : key;
          nodes[nodePath] = true; // Mark as expanded
          if (typeof value === "object" && value !== null) {
            Object.assign(nodes, expandAllNodes(value, nodePath));
          }
        });
        return nodes;
      };
      setExpandedNodes(expandAllNodes(item));
    }
  }, [modalOpen, item]);

  const handleCopy = () => {
    navigator.clipboard.writeText(JSON.stringify(item, null, 2));
    alert("JSON copied to clipboard!");
  };

  const handleDownload = () => {
    const blob = new Blob([JSON.stringify(item, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "domain-json.json";
    link.click();
  };

  const toggleNode = (path) => {
    setExpandedNodes((prev) => ({ ...prev, [path]: !prev[path] }));
  };

  // Recursive Tree Rendering
  const renderTree = (data, path = "") => {
    return Object.entries(data).map(([key, value]) => {
      const nodePath = path ? `${path}.${key}` : key;
      const isExpandable = typeof value === "object" && value !== null;
      const isExpanded = expandedNodes[nodePath];

      return (
        <Box key={nodePath} sx={{ ml: 2, mt: 1 }}>
          <Box
            sx={{
              display: "flex",
              alignItems: "center",
              cursor: isExpandable ? "pointer" : "default",
            }}
            onClick={() => isExpandable && toggleNode(nodePath)}
          >
            {isExpandable ? (
              isExpanded ? (
                <ExpandMoreIcon sx={{ fontSize: 16, mr: 1 }} />
              ) : (
                <ChevronRightIcon sx={{ fontSize: 16, mr: 1 }} />
              )
            ) : (
              <Box sx={{ width: 16, mr: 1 }} />
            )}
            <Typography
              component="span"
              sx={{
                fontWeight: isExpandable ? "bold" : "normal",
                color: isExpandable ? "#3f51b5" : "#000",
              }}
            >
              {key}:
            </Typography>
            {!isExpandable && (
              <Typography
                component="span"
                sx={{ ml: 1, color: "gray", fontFamily: "monospace" }}
              >
                {String(value)}
              </Typography>
            )}
          </Box>
          {isExpandable && isExpanded && (
            <Box sx={{ ml: 2 }}>{renderTree(value, nodePath)}</Box>
          )}
        </Box>
      );
    });
  };

  return (
    <Modal
      open={modalOpen}
      onClose={() => setModalOpen(false)}
      aria-labelledby="json-modal"
      aria-describedby="json-modal-description"
    >
      <Box
        sx={{
          position: "absolute",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          width: "600px",
          bgcolor: "background.paper",
          border: "1px solid #ddd",
          borderRadius: "10px",
          boxShadow: 24,
          p: 4,
          maxHeight: "80%",
          overflowY: "auto",
        }}
      >
        {/* Modal Header */}
        <Box
          sx={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            mb: 2,
          }}
        >
          <Typography
            id="json-modal"
            variant="h6"
            component="h2"
            sx={{ color: "#3f51b5" }}
          >
            Domain JSON Viewer
          </Typography>
          <Box>
            <Tooltip title="Copy JSON">
              <IconButton onClick={handleCopy}>
                <ContentCopyIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Download JSON">
              <IconButton onClick={handleDownload}>
                <FileDownloadIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Close">
              <IconButton onClick={() => setModalOpen(false)}>
                <CloseIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
          </Box>
        </Box>

        {/* Custom Tree Viewer */}
        <Box
          sx={{
            bgcolor: "#f5f5f5",
            padding: "10px",
            borderRadius: "5px",
            maxHeight: "400px",
            overflowY: "auto",
            border: "1px solid #ddd",
          }}
        >
          {renderTree(item)}
        </Box>
      </Box>
    </Modal>
  );
}

export default JsonModal;





  Line 173:39:  React Hook "useState" cannot be called inside a callback. React Hooks must be called in a React function 
component or a custom React Hook function  react-hooks/rules-of-hooks


import React, { useState } from "react";
import {
  Modal,
  Box,
  IconButton,
  Typography,
  Tooltip,
} from "@mui/material";
import CloseIcon from "@mui/icons-material/Close";
import FileDownloadIcon from "@mui/icons-material/FileDownload";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import ChevronRightIcon from "@mui/icons-material/ChevronRight";

function JsonModal({ modalOpen, setModalOpen, item }) {
  const handleCopy = () => {
    navigator.clipboard.writeText(JSON.stringify(item, null, 2));
    alert("JSON copied to clipboard!");
  };

  const handleDownload = () => {
    const blob = new Blob([JSON.stringify(item, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "domain-json.json";
    link.click();
  };

  // Recursive Tree Rendering
  const renderTree = (data) => {
    return Object.entries(data).map(([key, value], index) => {
      const [expanded, setExpanded] = useState(false);

      const isExpandable = typeof value === "object" && value !== null;

      return (
        <Box key={`${key}-${index}`} sx={{ ml: 2, mt: 1 }}>
          <Box
            sx={{
              display: "flex",
              alignItems: "center",
              cursor: isExpandable ? "pointer" : "default",
            }}
            onClick={() => isExpandable && setExpanded(!expanded)}
          >
            {isExpandable ? (
              expanded ? (
                <ExpandMoreIcon sx={{ fontSize: 16, mr: 1 }} />
              ) : (
                <ChevronRightIcon sx={{ fontSize: 16, mr: 1 }} />
              )
            ) : (
              <Box sx={{ width: 16, mr: 1 }} />
            )}
            <Typography
              component="span"
              sx={{
                fontWeight: isExpandable ? "bold" : "normal",
                color: isExpandable ? "#3f51b5" : "#000",
              }}
            >
              {key}:
            </Typography>
            {!isExpandable && (
              <Typography
                component="span"
                sx={{ ml: 1, color: "gray", fontFamily: "monospace" }}
              >
                {String(value)}
              </Typography>
            )}
          </Box>
          {isExpandable && expanded && (
            <Box sx={{ ml: 2 }}>{renderTree(value)}</Box>
          )}
        </Box>
      );
    });
  };

  return (
    <Modal
      open={modalOpen}
      onClose={() => setModalOpen(false)}
      aria-labelledby="json-modal"
      aria-describedby="json-modal-description"
    >
      <Box
        sx={{
          position: "absolute",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          width: "600px",
          bgcolor: "background.paper",
          border: "1px solid #ddd",
          borderRadius: "10px",
          boxShadow: 24,
          p: 4,
          maxHeight: "80%",
          overflowY: "auto",
        }}
      >
        {/* Modal Header */}
        <Box
          sx={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            mb: 2,
          }}
        >
          <Typography
            id="json-modal"
            variant="h6"
            component="h2"
            sx={{ color: "#3f51b5" }}
          >
            Domain JSON Viewer
          </Typography>
          <Box>
            <Tooltip title="Copy JSON">
              <IconButton onClick={handleCopy}>
                <ContentCopyIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Download JSON">
              <IconButton onClick={handleDownload}>
                <FileDownloadIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Close">
              <IconButton onClick={() => setModalOpen(false)}>
                <CloseIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
          </Box>
        </Box>

        {/* Custom Tree Viewer */}
        <Box
          sx={{
            bgcolor: "#f5f5f5",
            padding: "10px",
            borderRadius: "5px",
            maxHeight: "400px",
            overflowY: "auto",
            border: "1px solid #ddd",
          }}
        >
          {renderTree(item)}
        </Box>
      </Box>
    </Modal>
  );
}

export default JsonModal;


///////////////////////////////////////////////////////////


import React from "react";
import {
  Modal,
  Box,
  IconButton,
  Typography,
  Tooltip,
} from "@mui/material";
import CloseIcon from "@mui/icons-material/Close";
import FileDownloadIcon from "@mui/icons-material/FileDownload";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import { TreeView, TreeItem } from "@mui/x-tree-view";

function JsonModal({ modalOpen, setModalOpen, item }) {
  // Recursive function to render Tree Items
  const renderTree = (data, parentId = "root") => {
    return Object.keys(data).map((key, index) => {
      const value = data[key];
      const id = `${parentId}-${key}-${index}`; // Generate unique `id`

      if (typeof value === "object" && value !== null) {
        // Render nested objects or arrays
        return (
          <TreeItem key={id} id={id} nodeId={id} label={key}>
            {renderTree(value, id)}
          </TreeItem>
        );
      }

      // Render leaf node for primitive values
      return (
        <TreeItem
          key={id}
          id={id}
          nodeId={id}
          label={`${key}: ${value}`}
        />
      );
    });
  };

  const handleCopy = () => {
    navigator.clipboard.writeText(JSON.stringify(item, null, 2));
    alert("JSON copied to clipboard!");
  };

  const handleDownload = () => {
    const blob = new Blob([JSON.stringify(item, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "domain-json.json";
    link.click();
  };

  return (
    <Modal
      open={modalOpen}
      onClose={() => setModalOpen(false)}
      aria-labelledby="json-modal"
      aria-describedby="json-modal-description"
    >
      <Box
        sx={{
          position: "absolute",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          width: "600px",
          bgcolor: "background.paper",
          border: "1px solid #ddd",
          borderRadius: "10px",
          boxShadow: 24,
          p: 4,
          maxHeight: "80%",
          overflowY: "auto",
        }}
      >
        {/* Modal Header */}
        <Box
          sx={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            mb: 2,
          }}
        >
          <Typography
            id="json-modal"
            variant="h6"
            component="h2"
            sx={{ color: "#3f51b5" }}
          >
            Domain JSON Viewer
          </Typography>
          <Box>
            <Tooltip title="Copy JSON">
              <IconButton onClick={handleCopy}>
                <ContentCopyIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Download JSON">
              <IconButton onClick={handleDownload}>
                <FileDownloadIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Close">
              <IconButton onClick={() => setModalOpen(false)}>
                <CloseIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
          </Box>
        </Box>

        {/* TreeView Content */}
        <Box
          sx={{
            bgcolor: "#f5f5f5",
            padding: "10px",
            borderRadius: "5px",
            maxHeight: "400px",
            overflowY: "auto",
            border: "1px solid #ddd",
          }}
        >
          <TreeView
            defaultCollapseIcon={<CloseIcon />}
            defaultExpandIcon={<FileDownloadIcon />}
            sx={{
              flexGrow: 1,
              overflowY: "auto",
              fontFamily: "monospace",
              fontSize: "14px",
            }}
          >
            {renderTree(item)}
          </TreeView>
        </Box>
      </Box>
    </Modal>
  );
}

export default JsonModal;

////////////////////////////////////////////////////////


import React from "react";
import {
  Modal,
  Box,
  IconButton,
  Typography,
  Tooltip,
} from "@mui/material";
import CloseIcon from "@mui/icons-material/Close";
import FileDownloadIcon from "@mui/icons-material/FileDownload";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import { TreeView, TreeItem } from "@mui/lab";

function JsonModal({ modalOpen, setModalOpen, item }) {
  // Function to recursively render JSON as Tree Items
  const renderTree = (data, nodeId = "root") => {
    return Object.keys(data).map((key, index) => {
      const value = data[key];
      const currentNodeId = `${nodeId}-${key}-${index}`; // Generate unique nodeId

      if (typeof value === "object" && value !== null) {
        return (
          <TreeItem key={currentNodeId} nodeId={currentNodeId} label={key}>
            {renderTree(value, currentNodeId)}
          </TreeItem>
        );
      }

      return (
        <TreeItem
          key={currentNodeId}
          nodeId={currentNodeId}
          label={`${key}: ${value}`}
        />
      );
    });
  };

  const handleCopy = () => {
    navigator.clipboard.writeText(JSON.stringify(item, null, 2));
    alert("JSON copied to clipboard!");
  };

  const handleDownload = () => {
    const blob = new Blob([JSON.stringify(item, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "domain-json.json";
    link.click();
  };

  return (
    <Modal
      open={modalOpen}
      onClose={() => setModalOpen(false)}
      aria-labelledby="json-modal"
      aria-describedby="json-modal-description"
    >
      <Box
        sx={{
          position: "absolute",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          width: "600px",
          bgcolor: "background.paper",
          border: "1px solid #ddd",
          borderRadius: "10px",
          boxShadow: 24,
          p: 4,
          maxHeight: "80%",
          overflowY: "auto",
        }}
      >
        <Box
          sx={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            mb: 2,
          }}
        >
          <Typography
            id="json-modal"
            variant="h6"
            component="h2"
            sx={{ color: "#3f51b5" }}
          >
            Domain JSON Viewer
          </Typography>
          <Box>
            <Tooltip title="Copy JSON">
              <IconButton onClick={handleCopy}>
                <ContentCopyIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Download JSON">
              <IconButton onClick={handleDownload}>
                <FileDownloadIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Close">
              <IconButton onClick={() => setModalOpen(false)}>
                <CloseIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
          </Box>
        </Box>

        {/* TreeView Content */}
        <Box
          sx={{
            bgcolor: "#f5f5f5",
            padding: "10px",
            borderRadius: "5px",
            maxHeight: "400px",
            overflowY: "auto",
            border: "1px solid #ddd",
          }}
        >
          <TreeView
            defaultCollapseIcon={<CloseIcon />}
            defaultExpandIcon={<FileDownloadIcon />}
            sx={{
              flexGrow: 1,
              overflowY: "auto",
              fontFamily: "monospace",
              fontSize: "14px",
            }}
          >
            {renderTree(item)}
          </TreeView>
        </Box>
      </Box>
    </Modal>
  );
}

export default JsonModal;

//////////////////////////////////////////////////////////////



MUI X: The Tree View component requires all items to have a unique `id` property.
Alternatively, you can use the `getItemId` prop to specify a custom id for each item.
Two items were provided with the same id in the `items` prop: "undefined"
Error: MUI X: The Tree View component requires all items to have a unique `id` property.
Alternatively, you can use the `getItemId` prop to specify a custom id for each item.
Two items were provided with the same id in the `items` prop: "undefined"



import React from "react";
import {
  Modal,
  Box,
  IconButton,
  Typography,
  Tooltip,
} from "@mui/material";
import CloseIcon from "@mui/icons-material/Close";
import FileDownloadIcon from "@mui/icons-material/FileDownload";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";
import { TreeView, TreeItem } from "@mui/lab";

function JsonModal({ modalOpen, setModalOpen, renderJSON, item }) {
  // Function to recursively render JSON as Tree Items
  const renderTree = (data, nodeId = "root") => {
    return Object.keys(data).map((key, index) => {
      const value = data[key];
      const currentNodeId = `${nodeId}-${index}`;

      if (typeof value === "object" && value !== null) {
        // Render as nested TreeItem if value is an object or array
        return (
          <TreeItem key={currentNodeId} nodeId={currentNodeId} label={key}>
            {renderTree(value, currentNodeId)}
          </TreeItem>
        );
      }

      // Render as a single TreeItem for primitive values
      return (
        <TreeItem
          key={currentNodeId}
          nodeId={currentNodeId}
          label={`${key}: ${value}`}
        />
      );
    });
  };

  const handleCopy = () => {
    navigator.clipboard.writeText(JSON.stringify(item, null, 2));
    alert("JSON copied to clipboard!");
  };

  const handleDownload = () => {
    const blob = new Blob([JSON.stringify(item, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "domain-json.json";
    link.click();
  };

  return (
    <Modal
      open={modalOpen}
      onClose={() => setModalOpen(false)}
      aria-labelledby="json-modal"
      aria-describedby="json-modal-description"
    >
      <Box
        sx={{
          position: "absolute",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          width: "600px",
          bgcolor: "background.paper",
          border: "1px solid #ddd",
          borderRadius: "10px",
          boxShadow: 24,
          p: 4,
          maxHeight: "80%",
          overflowY: "auto",
        }}
      >
        {/* Top Bar with Close, Copy, and Download Buttons */}
        <Box
          sx={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            mb: 2,
          }}
        >
          <Typography
            id="json-modal"
            variant="h6"
            component="h2"
            sx={{ color: "#3f51b5" }}
          >
            Domain JSON Viewer
          </Typography>
          <Box>
            <Tooltip title="Copy JSON">
              <IconButton onClick={handleCopy}>
                <ContentCopyIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Download JSON">
              <IconButton onClick={handleDownload}>
                <FileDownloadIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Close">
              <IconButton onClick={() => setModalOpen(false)}>
                <CloseIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
          </Box>
        </Box>

        {/* TreeView Content */}
        <Box
          sx={{
            bgcolor: "#f5f5f5",
            padding: "10px",
            borderRadius: "5px",
            maxHeight: "400px",
            overflowY: "auto",
            border: "1px solid #ddd",
          }}
        >
          <TreeView
            defaultCollapseIcon={<CloseIcon />}
            defaultExpandIcon={<FileDownloadIcon />}
            sx={{
              flexGrow: 1,
              overflowY: "auto",
              fontFamily: "monospace",
              fontSize: "14px",
            }}
          >
            {renderTree(item)}
          </TreeView>
        </Box>
      </Box>
    </Modal>
  );
}

export default JsonModal;

////////////////////////////////////////////////////////////////////


import React from "react";
import { Modal, Box, IconButton, Typography, Tooltip } from "@mui/material";
import CloseIcon from "@mui/icons-material/Close";
import FileDownloadIcon from "@mui/icons-material/FileDownload";
import ContentCopyIcon from "@mui/icons-material/ContentCopy";

function JsonModal({ modalOpen, setModalOpen, renderJSON, item }) {
  const handleCopy = () => {
    navigator.clipboard.writeText(JSON.stringify(item, null, 2));
    alert("JSON copied to clipboard!");
  };

  const handleDownload = () => {
    const blob = new Blob([JSON.stringify(item, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = "domain-json.json";
    link.click();
  };

  return (
    <Modal
      open={modalOpen}
      onClose={() => setModalOpen(false)}
      aria-labelledby="json-modal"
      aria-describedby="json-modal-description"
    >
      <Box
        sx={{
          position: "absolute",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          width: "600px",
          bgcolor: "background.paper",
          border: "1px solid #ddd",
          borderRadius: "10px",
          boxShadow: 24,
          p: 4,
          maxHeight: "80%",
          overflowY: "auto",
        }}
      >
        {/* Top Bar with Close, Copy, and Download Buttons */}
        <Box
          sx={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            mb: 2,
          }}
        >
          <Typography
            id="json-modal"
            variant="h6"
            component="h2"
            sx={{ color: "#3f51b5" }}
          >
            Domain JSON Viewer
          </Typography>
          <Box>
            <Tooltip title="Copy JSON">
              <IconButton onClick={handleCopy}>
                <ContentCopyIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Download JSON">
              <IconButton onClick={handleDownload}>
                <FileDownloadIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
            <Tooltip title="Close">
              <IconButton onClick={() => setModalOpen(false)}>
                <CloseIcon sx={{ color: "#3f51b5" }} />
              </IconButton>
            </Tooltip>
          </Box>
        </Box>

        {/* JSON Rendered Content */}
        <Box
          sx={{
            bgcolor: "#f5f5f5",
            padding: "10px",
            borderRadius: "5px",
            maxHeight: "400px",
            overflowY: "auto",
            border: "1px solid #ddd",
          }}
        >
          <pre style={{ fontFamily: "monospace", fontSize: "14px" }}>
            {JSON.stringify(item, null, 2)}
          </pre>
        </Box>
      </Box>
    </Modal>
  );
}

export default JsonModal;
//////////////////////////////
      <Modal
        open={modalOpen}
        onClose={() => setModalOpen(false)}
        aria-labelledby="json-modal"
        aria-describedby="json-modal-description"
      >
        <Box
          sx={{
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: "600px",
            bgcolor: "background.paper",
            border: "1px solid #ddd",
            borderRadius: "10px",
            boxShadow: 24,
            p: 4,
            maxHeight: "80%",
            overflowY: "auto",
          }}
        >
          <Typography
            id="json-modal"
            variant="h6"
            component="h2"
            sx={{ textAlign: "center", marginBottom: "20px", color: "#3f51b5" }}
          >
            JSON Viewer
          </Typography>

          <TextField
            fullWidth
            variant="outlined"
            size="small"
            label="Filter JSON"
            value={filterText}
            onChange={(e) => setFilterText(e.target.value)}
            sx={{
              marginBottom: "20px",
            }}
          />

          {/* <RichTreeView
            defaultCollapseIcon={<ExpandMoreIcon />}
            defaultExpandIcon={<ChevronRightIcon />}
            sx={{ flexGrow: 1, overflowY: "auto" }}
          > */}
            {renderJSON(item)}
          {/* </RichTreeView> */}

          <Box sx={{ textAlign: "center", marginTop: "20px" }}>
            <button
              onClick={() => setModalOpen(false)}
              style={{
                backgroundColor: "#3f51b5",
                color: "#fff",
                padding: "10px 20px",
                border: "none",
                borderRadius: "5px",
                cursor: "pointer",
              }}
            >
              Close
            </button>
          </Box>
        </Box>
      </Modal>








.icon-button-right {
  margin-left: auto; /* Pushes the button to the far right */
  display: flex;     /* Ensures alignment if used in a flex container */
  align-items: center;
}



<IconButton >
            <VisibilityIcon sx={{ color: "grey" , }} />
      </IconButton>


import './Navbar.scss';
import 'font-awesome/css/font-awesome.min.css';
import PolicyIcon from '@mui/icons-material/Policy';

function Navbar() {
  return (
    <div className="navBar">
      <div />
      <img className="logo" src="Images/sc-logo.svg" alt="Logo" />
      <div className="bpsi">
        <span className="bpsi-text">BPSI</span>
        <span className="bpsi-title">Smart</span>
        <PolicyIcon className="bpsi-icon" />
      </div>
      <div className="user">
        <span className="user-icon">
          {/* <i className="fas fa-user" /> */}
          <div className="user-name">BPSI Team</div>
        </span>
      </div>
    </div>
  );
}

export default Navbar;



@use '../../Colors.scss' as c;

.navBar {
  height: 60px;
  width: 100%;
  background-image: linear-gradient(to right, #00008B, #0096FF);
  display: flex;
  align-items: center;
}

.logo {
  margin-left: 20px;
  margin-right: 20px;
  margin-top: 10px;
  margin-bottom: 10px;
}

.bpsi {
  display: flex;
  align-items: center; /* Align icon and text vertically */
  color: #0FFF50;
  margin-top: 10px;
  margin-left: 20px;
  flex-grow: 1; /* Push the "user" section to the right */
}

.bpsi-text {
  font-size: medium;
  margin-right: 5px;
}

.bpsi-title {
  font-size: bold;
  color: #fff;
  margin-right: 5px;
}

.bpsi-icon {
  color: #fff;
  font-size: 20px; /* Adjust the icon size to match text */
}

.user {
  display: flex;
  align-items: center; /* Align "user" section items vertically */
  float: right;
  margin-left: 20px;
  margin-right: 20px;
}

.user-name {
  color: white;
  font-size: medium;
}

.user-icon {
  font-size: 20px;
  margin-right: 10px;
  color: white;
}


////////////////////

<div className="bpsi">BPSI  <text className="bpsi-title">Smart  </text>  <PolicyIcon  /></div> 

const getHighlightedData = (obj) => {
  const result = [];
  const searchWords = searchTerm
    ?.toLowerCase()
    .trim()
    .split(/\s+/); // Split the search term into individual words

  if (!searchWords || searchWords.length === 0) return result;

  Object.entries(obj).forEach(([key, value]) => {
    const isNestedObject = typeof value === "object" && value !== null;

    // Ensure the key and value are strings for comparison
    const keyString = key?.toLowerCase() || ""; // Fallback to empty string if undefined
    const valueString = value?.toString().toLowerCase() || ""; // Fallback to empty string if undefined

    // Check if any search word matches the key or value
    const keyMatches = searchWords.some((word) => keyString.includes(word));
    const valueMatches = searchWords.some((word) => valueString.includes(word));

    if (isNestedObject) {
      // Recursively process nested objects
      result.push(...getHighlightedData(value));
    } else if (keyMatches || valueMatches) {
      // Add matches to the result
      result.push({ key, value });
    }
  });

  return result;
};






const getHighlightedData = (obj) => {
  const result = [];
  const searchWords = searchTerm
    ?.toLowerCase()
    .trim()
    .split(/\s+/); // Ensure even a single word becomes an array

  if (!searchWords || searchWords.length === 0) return result;

  Object.entries(obj).forEach(([key, value]) => {
    const isNestedObject = typeof value === "object" && value !== null;

    // Convert to strings for comparison and handle numbers
    const keyString = key.toLowerCase();
    const valueString = value?.toString().toLowerCase();

    const keyMatches = searchWords.some((word) => keyString.includes(word));
    const valueMatches = searchWords.some((word) =>
      valueString.includes(word)
    );

    if (isNestedObject) {
      // Recursively check nested objects
      result.push(...getHighlightedData(value));
    } else if (keyMatches || valueMatches) {
      // Push matches to the result array
      result.push({ key, value });
    }
  });

  return result;
};








const getHighlightedData = (obj) => {
  const result = [];
  const searchWords = searchTerm
    ?.toLowerCase()
    .trim()
    .split(/\s+/); // Ensure even a single word becomes an array

  if (!searchWords || searchWords.length === 0) return result;

  Object.entries(obj).forEach(([key, value]) => {
    const isNestedObject = typeof value === "object" && value !== null;

    const keyMatches = searchWords.some((word) =>
      key.toLowerCase().includes(word)
    );

    const valueMatches =
      typeof value === "string" &&
      searchWords.some((word) => value.toLowerCase().includes(word));

    if (isNestedObject) {
      // Recursively check nested objects
      result.push(...getHighlightedData(value));
    } else if (keyMatches || valueMatches) {
      // Push matches to the result array
      result.push({ key, value });
    }
  });

  return result;
};




const getHighlightedData = (obj) => {
  const result = [];
  const searchWords = searchTerm
    ?.toLowerCase()
    .trim()
    .split(/\s+/); // Split search term into individual words

  if (!searchWords || searchWords.length === 0) return result;

  Object.entries(obj).forEach(([key, value]) => {
    const isNestedObject = typeof value === "object" && value !== null;
    const keyMatches = searchWords.some((word) =>
      key.toLowerCase().includes(word)
    );
    const valueMatches =
      typeof value === "string" &&
      searchWords.some((word) => value.toLowerCase().includes(word));

    if (isNestedObject) {
      // Recursively get matches for nested objects
      result.push(...getHighlightedData(value));
    } else if (keyMatches || valueMatches) {
      // Push matches to the result
      result.push({ key, value });
    }
  });

  return result;
};

// Highlighted Data
const highlightedData = getHighlightedData(item);


<Typography
  variant="h10"
  style={{
    color: "#333",
    fontSize: 14,
  }}
>
  {highlightedData.length > 0 ? (
    highlightedData.map(({ key, value }, index) => (
      <span key={index}>
        <strong>{highlightText(key)}:</strong> {highlightText(value?.toString())}
        <br />
      </span>
    ))
  ) : (
    <span>No matches found</span>
  )}
</Typography>






  const getHighlightedData = (obj) => {
  const result = [];
  const searchWords = searchTerm
    ?.toLowerCase()
    .trim()
    .split(/\s+/); // Split search term into individual words

  if (!searchWords || searchWords.length === 0) return result;

  Object.entries(obj).forEach(([key, value]) => {
    const isNestedObject = typeof value === "object" && value !== null;
    const keyMatches = searchWords.some((word) =>
      key.toLowerCase().includes(word)
    );
    const valueMatches =
      typeof value === "string" &&
      searchWords.some((word) => value.toLowerCase().includes(word));

    if (isNestedObject) {
      // Recursively get matches for nested objects
      result.push(...getHighlightedData(value));
    } else if (keyMatches || valueMatches) {
      // Push matches to the result
      result.push({ key, value });
    }
  });

  return result;
};

// Highlighted Data
const highlightedData = getHighlightedData(item)const getHighlightedData = (obj) => {
    const result = [];
    Object.entries(obj).forEach(([key, value]) => {
      if (typeof value === "object" && value !== null) {
        result.push(...getHighlightedData(value));
      } else if (
        (key.toLowerCase().includes(searchTerm.toLowerCase()) ||
          value?.toString().toLowerCase().includes(searchTerm.toLowerCase())) &&
        searchTerm
      ) {
        result.push({ key, value });
      }
    });
    return result;
  };

  const highlightedData = getHighlightedData(item);






const getHighlightedData = (obj) => {
  const result = [];
  const escapedSearchTerm = escapeRegExp(searchTerm.trim().toLowerCase());
  const searchRegex = new RegExp(escapedSearchTerm, "gi");

  Object.entries(obj).forEach(([key, value]) => {
    if (typeof value === "object" && value !== null) {
      result.push(...getHighlightedData(value));
    } else {
      const keyMatches = searchRegex.test(key.toLowerCase());
      const valueMatches =
        typeof value === "string" && searchRegex.test(value.toLowerCase());

      if (keyMatches || valueMatches) {
        result.push({ key, value });
      }
    }
  });

  return result;
};

const highlightText = (text) => {
  if (!searchTerm || typeof text !== "string") return text;

  const escapedSearchTerm = escapeRegExp(searchTerm.trim());
  const regex = new RegExp(`(${escapedSearchTerm})`, "gi");

  const parts = text.split(regex);

  return parts.map((part, index) =>
    regex.test(part) ? (
      <span
        key={index}
        style={{
          backgroundColor: "#ffe58a",
          fontWeight: "bold",
          padding: "0 2px",
          borderRadius: "2px",
        }}
      >
        {part}
      </span>
    ) : (
      part
    )
  );
};

return (
  <Typography
    variant="h10"
    style={{
      color: "#333",
      fontSize: 14,
    }}
  >
    {highlightedData.length > 0 ? (
      highlightedData.map(({ key, value }, i) => (
        <span key={i}>
          <strong>{highlightText(key)}:</strong> {highlightText(value?.toString())}
          <br />
        </span>
      ))
    ) : (
      <span>No matches found</span>
    )}
  </Typography>
);




77777777777777


const getHighlightedData = (obj) => {
  const result = [];
  const escapedSearchTerm = escapeRegExp(searchTerm.trim().toLowerCase());

  Object.entries(obj).forEach(([key, value]) => {
    if (typeof value === "object" && value !== null) {
      // Recursively process nested objects
      result.push(...getHighlightedData(value));
    } else {
      // Match keys or values against the searchTerm
      const keyMatches = key.toLowerCase().includes(escapedSearchTerm);
      const valueMatches =
        typeof value === "string" &&
        value.toLowerCase().includes(escapedSearchTerm);

      if (keyMatches || valueMatches) {
        result.push({ key, value });
      }
    }
  });

  return result;
};


<Typography
  variant="h10"
  style={{
    color: "#333",
    fontSize: 14,
  }}
>
  {highlightedData.length > 0 ? (
    highlightedData.map(({ key, value }, i) => (
      <span key={i}>
        <strong>{highlightText(key)}:</strong> {highlightText(value?.toString())}
        <br />
      </span>
    ))
  ) : (
    <span>No matches found</span>
  )}
</Typography>


import React, { useState } from "react";
import Card from "@mui/material/Card";
import CardContent from "@mui/material/CardContent";
import Typography from "@mui/material/Typography";
import Box from "@mui/material/Box";
// import AddCircleRoundedIcon from "@mui/icons-material/AddCircleRounded";
// import RemoveCircleRoundedIcon from "@mui/icons-material/RemoveCircleRounded";
// import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
// import ChevronRightIcon from '@mui/icons-material/ChevronRight';
import VisibilityIcon from '@mui/icons-material/Visibility';
import { Button, IconButton, Modal, TextField } from "@mui/material";
import { TreeItem, RichTreeView } from "@mui/x-tree-view";

const HighlightedCardItem = ({ item, searchTerm }) => {
  const [modalOpen, setModalOpen] = useState(false);
  const [filterText, setFilterText] = useState("");
  const escapeRegExp = (string) => {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // Escapes special characters for regex
  };
  
  const highlightText = (text) => {
    if (!searchTerm || typeof text !== "string") return text;
  
    // Escape special characters in the searchTerm and create regex for multiple words
    const escapedSearchTerm = escapeRegExp(searchTerm.trim());
    const words = escapedSearchTerm.split(/\s+/).map((word) => escapeRegExp(word)); // Split into words
    const regex = new RegExp(`(${words.join("|")})`, "gi"); // Create regex for all words
  
    // Split text into parts using the regex
    const parts = text.split(regex);
  
    return parts.map((part, index) =>
      regex.test(part) ? (
        <span
          key={index}
          style={{
            backgroundColor: "#ffe58a",
            fontWeight: "bold",
            padding: "0 2px",
            borderRadius: "2px",
          }}
        >
          {part}
        </span>
      ) : (
        part
      )
    );
  };
  

  const renderJSON = (obj, parentKey = "") => {
    return Object.entries(obj).map(([key, value]) => {
      const isExpandable = typeof value === "object" && value !== null;
      const matchesFilter =
        key.toLowerCase().includes(filterText.toLowerCase()) ||
        (!isExpandable &&
          value?.toString().toLowerCase().includes(filterText.toLowerCase()));

      if (!matchesFilter) return null;

      return (
        <div key={`${parentKey}.${key}`} style={{ marginLeft: "20px", marginBottom: "5px" }}>
          <Typography
            variant="body2"
            component="span"
            style={{ fontWeight: "bold", color: "#3f51b5", fontSize: 12 }}
          >
            {highlightText(key)}:
          </Typography>{" "}
          {isExpandable ? (
            <div>{renderJSON(value, `${parentKey}.${key}`)}</div>
          ) : (
            <Typography variant="body2" component="span" style={{ fontSize: 12 }}>
              {highlightText(value?.toString())}
            </Typography>
          )}
        </div>
      );
    });
  };

  
  // Recursive function to render tree items
  const renderTreeItems = (data, parentKey = "") => {
    if (data === null || data === undefined) return null;

    return Object.entries(data).map(([key, value]) => {
      const nodeId = `${parentKey}-${key}`;
      const isExpandable = typeof value === "object" && value !== null;

      // Check if the key or value matches the filter
      const matchesFilter =
        key.toLowerCase().includes(filterText.toLowerCase()) ||
        (typeof value === "string" &&
          value.toLowerCase().includes(filterText.toLowerCase()));

      // Skip items that don't match the filter
      if (filterText && !matchesFilter) return null;

      return (
        <TreeItem
          key={nodeId}
          nodeId={nodeId}
          label={
            <span>
              <strong>{key}:</strong> {isExpandable ? null : value?.toString()}
            </span>
          }
        >
          {isExpandable && renderTreeItems(value, nodeId)}
        </TreeItem>
      );
    });
  };

  const getHighlightedData = (obj) => {
    const result = [];
    Object.entries(obj).forEach(([key, value]) => {
      if (typeof value === "object" && value !== null) {
        result.push(...getHighlightedData(value));
      } else if (
        (key.toLowerCase().includes(searchTerm.toLowerCase()) ||
          value?.toString().toLowerCase().includes(searchTerm.toLowerCase())) &&
        searchTerm
      ) {
        result.push({ key, value });
      }
    });
    return result;
  };

  const highlightedData = getHighlightedData(item);

  return (
    <Card
  variant="outlined"
  style={{
    marginBottom: "20px",
    border: "1px solid #ddd",
    boxShadow: "0px 4px 8px rgba(0, 0, 0, 0.2)",
    borderRadius: "10px",
    width: "80%",
    margin: "20px auto", // Centers the Card horizontally
  }}
>
  
      <CardContent
        style={{
          backgroundColor: "#f9f9f9",
          padding: "20px",
          borderBottom: "1px solid #ddd",

        }}
      >

        <Box
          style={{
            display: "flex",
            alignItems: "center", // Vertically align items
            justifyContent: "space-between", // Text on the left, button on the right
            padding: "10px 0", // Add vertical spacing around the row
          }}
        >
          <Typography
            variant="h10"
            style={{
              color: "#333",
              fontSize: 14,
            }}
          >
            {highlightedData.length > 0 ? (
              highlightedData.map(({ key, value }, i) => (

                <span key={i}>
                  <strong>{highlightText(key)}:</strong>{highlightText(value?.toString())}
                  <br/>
                </span>
              ))
            ) : (
              <span>No matches found</span>
            )}


  
          </Typography>

          <IconButton onClick={() => setModalOpen(true)}>
            <VisibilityIcon sx={{ color: "grey" }} />
          </IconButton>
        </Box>

      </CardContent>

      <Modal
        open={modalOpen}
        onClose={() => setModalOpen(false)}
        aria-labelledby="json-modal"
        aria-describedby="json-modal-description"
      >
        <Box
          sx={{
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: "600px",
            bgcolor: "background.paper",
            border: "1px solid #ddd",
            borderRadius: "10px",
            boxShadow: 24,
            p: 4,
            maxHeight: "80%",
            overflowY: "auto",
          }}
        >
          <Typography
            id="json-modal"
            variant="h6"
            component="h2"
            sx={{ textAlign: "center", marginBottom: "20px", color: "#3f51b5" }}
          >
            JSON Viewer
          </Typography>

          <TextField
            fullWidth
            variant="outlined"
            size="small"
            label="Filter JSON"
            value={filterText}
            onChange={(e) => setFilterText(e.target.value)}
            sx={{
              marginBottom: "20px",
            }}
          />

          {/* <RichTreeView
            defaultCollapseIcon={<ExpandMoreIcon />}
            defaultExpandIcon={<ChevronRightIcon />}
            sx={{ flexGrow: 1, overflowY: "auto" }}
          > */}
            {renderJSON(item)}
          {/* </RichTreeView> */}

          <Box sx={{ textAlign: "center", marginTop: "20px" }}>
            <button
              onClick={() => setModalOpen(false)}
              style={{
                backgroundColor: "#3f51b5",
                color: "#fff",
                padding: "10px 20px",
                border: "none",
                borderRadius: "5px",
                cursor: "pointer",
              }}
            >
              Close
            </button>
          </Box>
        </Box>
      </Modal>
    </Card>
  );
};

const HighlightedCard = ({ data, searchTerm }) => {
  return (
    <div style={{ padding: "20px" }}>
      {data.map((item, index) => (
        <HighlightedCardItem key={index} item={item} searchTerm={searchTerm} />
      ))}
    </div>
  );
};

export default HighlightedCard;

