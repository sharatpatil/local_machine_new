const getHighlightedData = (obj) => {
  const result = [];
  const searchWords = searchTerm
    ?.toLowerCase()
    .trim()
    .split(/\s+/); // Ensure even a single word becomes an array

  if (!searchWords || searchWords.length === 0) return result;

  Object.entries(obj).forEach(([key, value]) => {
    const isNestedObject = typeof value === "object" && value !== null;

    const keyMatches = searchWords.some((word) =>
      key.toLowerCase().includes(word)
    );

    const valueMatches =
      typeof value === "string" &&
      searchWords.some((word) => value.toLowerCase().includes(word));

    if (isNestedObject) {
      // Recursively check nested objects
      result.push(...getHighlightedData(value));
    } else if (keyMatches || valueMatches) {
      // Push matches to the result array
      result.push({ key, value });
    }
  });

  return result;
};




const getHighlightedData = (obj) => {
  const result = [];
  const searchWords = searchTerm
    ?.toLowerCase()
    .trim()
    .split(/\s+/); // Split search term into individual words

  if (!searchWords || searchWords.length === 0) return result;

  Object.entries(obj).forEach(([key, value]) => {
    const isNestedObject = typeof value === "object" && value !== null;
    const keyMatches = searchWords.some((word) =>
      key.toLowerCase().includes(word)
    );
    const valueMatches =
      typeof value === "string" &&
      searchWords.some((word) => value.toLowerCase().includes(word));

    if (isNestedObject) {
      // Recursively get matches for nested objects
      result.push(...getHighlightedData(value));
    } else if (keyMatches || valueMatches) {
      // Push matches to the result
      result.push({ key, value });
    }
  });

  return result;
};

// Highlighted Data
const highlightedData = getHighlightedData(item);


<Typography
  variant="h10"
  style={{
    color: "#333",
    fontSize: 14,
  }}
>
  {highlightedData.length > 0 ? (
    highlightedData.map(({ key, value }, index) => (
      <span key={index}>
        <strong>{highlightText(key)}:</strong> {highlightText(value?.toString())}
        <br />
      </span>
    ))
  ) : (
    <span>No matches found</span>
  )}
</Typography>






  const getHighlightedData = (obj) => {
  const result = [];
  const searchWords = searchTerm
    ?.toLowerCase()
    .trim()
    .split(/\s+/); // Split search term into individual words

  if (!searchWords || searchWords.length === 0) return result;

  Object.entries(obj).forEach(([key, value]) => {
    const isNestedObject = typeof value === "object" && value !== null;
    const keyMatches = searchWords.some((word) =>
      key.toLowerCase().includes(word)
    );
    const valueMatches =
      typeof value === "string" &&
      searchWords.some((word) => value.toLowerCase().includes(word));

    if (isNestedObject) {
      // Recursively get matches for nested objects
      result.push(...getHighlightedData(value));
    } else if (keyMatches || valueMatches) {
      // Push matches to the result
      result.push({ key, value });
    }
  });

  return result;
};

// Highlighted Data
const highlightedData = getHighlightedData(item)const getHighlightedData = (obj) => {
    const result = [];
    Object.entries(obj).forEach(([key, value]) => {
      if (typeof value === "object" && value !== null) {
        result.push(...getHighlightedData(value));
      } else if (
        (key.toLowerCase().includes(searchTerm.toLowerCase()) ||
          value?.toString().toLowerCase().includes(searchTerm.toLowerCase())) &&
        searchTerm
      ) {
        result.push({ key, value });
      }
    });
    return result;
  };

  const highlightedData = getHighlightedData(item);






const getHighlightedData = (obj) => {
  const result = [];
  const escapedSearchTerm = escapeRegExp(searchTerm.trim().toLowerCase());
  const searchRegex = new RegExp(escapedSearchTerm, "gi");

  Object.entries(obj).forEach(([key, value]) => {
    if (typeof value === "object" && value !== null) {
      result.push(...getHighlightedData(value));
    } else {
      const keyMatches = searchRegex.test(key.toLowerCase());
      const valueMatches =
        typeof value === "string" && searchRegex.test(value.toLowerCase());

      if (keyMatches || valueMatches) {
        result.push({ key, value });
      }
    }
  });

  return result;
};

const highlightText = (text) => {
  if (!searchTerm || typeof text !== "string") return text;

  const escapedSearchTerm = escapeRegExp(searchTerm.trim());
  const regex = new RegExp(`(${escapedSearchTerm})`, "gi");

  const parts = text.split(regex);

  return parts.map((part, index) =>
    regex.test(part) ? (
      <span
        key={index}
        style={{
          backgroundColor: "#ffe58a",
          fontWeight: "bold",
          padding: "0 2px",
          borderRadius: "2px",
        }}
      >
        {part}
      </span>
    ) : (
      part
    )
  );
};

return (
  <Typography
    variant="h10"
    style={{
      color: "#333",
      fontSize: 14,
    }}
  >
    {highlightedData.length > 0 ? (
      highlightedData.map(({ key, value }, i) => (
        <span key={i}>
          <strong>{highlightText(key)}:</strong> {highlightText(value?.toString())}
          <br />
        </span>
      ))
    ) : (
      <span>No matches found</span>
    )}
  </Typography>
);




77777777777777


const getHighlightedData = (obj) => {
  const result = [];
  const escapedSearchTerm = escapeRegExp(searchTerm.trim().toLowerCase());

  Object.entries(obj).forEach(([key, value]) => {
    if (typeof value === "object" && value !== null) {
      // Recursively process nested objects
      result.push(...getHighlightedData(value));
    } else {
      // Match keys or values against the searchTerm
      const keyMatches = key.toLowerCase().includes(escapedSearchTerm);
      const valueMatches =
        typeof value === "string" &&
        value.toLowerCase().includes(escapedSearchTerm);

      if (keyMatches || valueMatches) {
        result.push({ key, value });
      }
    }
  });

  return result;
};


<Typography
  variant="h10"
  style={{
    color: "#333",
    fontSize: 14,
  }}
>
  {highlightedData.length > 0 ? (
    highlightedData.map(({ key, value }, i) => (
      <span key={i}>
        <strong>{highlightText(key)}:</strong> {highlightText(value?.toString())}
        <br />
      </span>
    ))
  ) : (
    <span>No matches found</span>
  )}
</Typography>


import React, { useState } from "react";
import Card from "@mui/material/Card";
import CardContent from "@mui/material/CardContent";
import Typography from "@mui/material/Typography";
import Box from "@mui/material/Box";
// import AddCircleRoundedIcon from "@mui/icons-material/AddCircleRounded";
// import RemoveCircleRoundedIcon from "@mui/icons-material/RemoveCircleRounded";
// import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
// import ChevronRightIcon from '@mui/icons-material/ChevronRight';
import VisibilityIcon from '@mui/icons-material/Visibility';
import { Button, IconButton, Modal, TextField } from "@mui/material";
import { TreeItem, RichTreeView } from "@mui/x-tree-view";

const HighlightedCardItem = ({ item, searchTerm }) => {
  const [modalOpen, setModalOpen] = useState(false);
  const [filterText, setFilterText] = useState("");
  const escapeRegExp = (string) => {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // Escapes special characters for regex
  };
  
  const highlightText = (text) => {
    if (!searchTerm || typeof text !== "string") return text;
  
    // Escape special characters in the searchTerm and create regex for multiple words
    const escapedSearchTerm = escapeRegExp(searchTerm.trim());
    const words = escapedSearchTerm.split(/\s+/).map((word) => escapeRegExp(word)); // Split into words
    const regex = new RegExp(`(${words.join("|")})`, "gi"); // Create regex for all words
  
    // Split text into parts using the regex
    const parts = text.split(regex);
  
    return parts.map((part, index) =>
      regex.test(part) ? (
        <span
          key={index}
          style={{
            backgroundColor: "#ffe58a",
            fontWeight: "bold",
            padding: "0 2px",
            borderRadius: "2px",
          }}
        >
          {part}
        </span>
      ) : (
        part
      )
    );
  };
  

  const renderJSON = (obj, parentKey = "") => {
    return Object.entries(obj).map(([key, value]) => {
      const isExpandable = typeof value === "object" && value !== null;
      const matchesFilter =
        key.toLowerCase().includes(filterText.toLowerCase()) ||
        (!isExpandable &&
          value?.toString().toLowerCase().includes(filterText.toLowerCase()));

      if (!matchesFilter) return null;

      return (
        <div key={`${parentKey}.${key}`} style={{ marginLeft: "20px", marginBottom: "5px" }}>
          <Typography
            variant="body2"
            component="span"
            style={{ fontWeight: "bold", color: "#3f51b5", fontSize: 12 }}
          >
            {highlightText(key)}:
          </Typography>{" "}
          {isExpandable ? (
            <div>{renderJSON(value, `${parentKey}.${key}`)}</div>
          ) : (
            <Typography variant="body2" component="span" style={{ fontSize: 12 }}>
              {highlightText(value?.toString())}
            </Typography>
          )}
        </div>
      );
    });
  };

  
  // Recursive function to render tree items
  const renderTreeItems = (data, parentKey = "") => {
    if (data === null || data === undefined) return null;

    return Object.entries(data).map(([key, value]) => {
      const nodeId = `${parentKey}-${key}`;
      const isExpandable = typeof value === "object" && value !== null;

      // Check if the key or value matches the filter
      const matchesFilter =
        key.toLowerCase().includes(filterText.toLowerCase()) ||
        (typeof value === "string" &&
          value.toLowerCase().includes(filterText.toLowerCase()));

      // Skip items that don't match the filter
      if (filterText && !matchesFilter) return null;

      return (
        <TreeItem
          key={nodeId}
          nodeId={nodeId}
          label={
            <span>
              <strong>{key}:</strong> {isExpandable ? null : value?.toString()}
            </span>
          }
        >
          {isExpandable && renderTreeItems(value, nodeId)}
        </TreeItem>
      );
    });
  };

  const getHighlightedData = (obj) => {
    const result = [];
    Object.entries(obj).forEach(([key, value]) => {
      if (typeof value === "object" && value !== null) {
        result.push(...getHighlightedData(value));
      } else if (
        (key.toLowerCase().includes(searchTerm.toLowerCase()) ||
          value?.toString().toLowerCase().includes(searchTerm.toLowerCase())) &&
        searchTerm
      ) {
        result.push({ key, value });
      }
    });
    return result;
  };

  const highlightedData = getHighlightedData(item);

  return (
    <Card
  variant="outlined"
  style={{
    marginBottom: "20px",
    border: "1px solid #ddd",
    boxShadow: "0px 4px 8px rgba(0, 0, 0, 0.2)",
    borderRadius: "10px",
    width: "80%",
    margin: "20px auto", // Centers the Card horizontally
  }}
>
  
      <CardContent
        style={{
          backgroundColor: "#f9f9f9",
          padding: "20px",
          borderBottom: "1px solid #ddd",

        }}
      >

        <Box
          style={{
            display: "flex",
            alignItems: "center", // Vertically align items
            justifyContent: "space-between", // Text on the left, button on the right
            padding: "10px 0", // Add vertical spacing around the row
          }}
        >
          <Typography
            variant="h10"
            style={{
              color: "#333",
              fontSize: 14,
            }}
          >
            {highlightedData.length > 0 ? (
              highlightedData.map(({ key, value }, i) => (

                <span key={i}>
                  <strong>{highlightText(key)}:</strong>{highlightText(value?.toString())}
                  <br/>
                </span>
              ))
            ) : (
              <span>No matches found</span>
            )}


  
          </Typography>

          <IconButton onClick={() => setModalOpen(true)}>
            <VisibilityIcon sx={{ color: "grey" }} />
          </IconButton>
        </Box>

      </CardContent>

      <Modal
        open={modalOpen}
        onClose={() => setModalOpen(false)}
        aria-labelledby="json-modal"
        aria-describedby="json-modal-description"
      >
        <Box
          sx={{
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: "600px",
            bgcolor: "background.paper",
            border: "1px solid #ddd",
            borderRadius: "10px",
            boxShadow: 24,
            p: 4,
            maxHeight: "80%",
            overflowY: "auto",
          }}
        >
          <Typography
            id="json-modal"
            variant="h6"
            component="h2"
            sx={{ textAlign: "center", marginBottom: "20px", color: "#3f51b5" }}
          >
            JSON Viewer
          </Typography>

          <TextField
            fullWidth
            variant="outlined"
            size="small"
            label="Filter JSON"
            value={filterText}
            onChange={(e) => setFilterText(e.target.value)}
            sx={{
              marginBottom: "20px",
            }}
          />

          {/* <RichTreeView
            defaultCollapseIcon={<ExpandMoreIcon />}
            defaultExpandIcon={<ChevronRightIcon />}
            sx={{ flexGrow: 1, overflowY: "auto" }}
          > */}
            {renderJSON(item)}
          {/* </RichTreeView> */}

          <Box sx={{ textAlign: "center", marginTop: "20px" }}>
            <button
              onClick={() => setModalOpen(false)}
              style={{
                backgroundColor: "#3f51b5",
                color: "#fff",
                padding: "10px 20px",
                border: "none",
                borderRadius: "5px",
                cursor: "pointer",
              }}
            >
              Close
            </button>
          </Box>
        </Box>
      </Modal>
    </Card>
  );
};

const HighlightedCard = ({ data, searchTerm }) => {
  return (
    <div style={{ padding: "20px" }}>
      {data.map((item, index) => (
        <HighlightedCardItem key={index} item={item} searchTerm={searchTerm} />
      ))}
    </div>
  );
};

export default HighlightedCard;

